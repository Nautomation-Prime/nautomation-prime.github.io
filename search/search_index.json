{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home - Cisco Python Automation","text":"","tags":["Home","Python","Cisco","Network Automation","Netmiko"]},{"location":"#cisco-python-automation-explained-line-by-line","title":"Cisco Python Automation, Explained Line-by-Line","text":"","tags":["Home","Python","Cisco","Network Automation","Netmiko"]},{"location":"#welcome","title":"Welcome","text":"<p>Nautomation Prime bridges the gap between complex Cisco infrastructure and streamlined Python-driven automation. </p> <p>We believe network code should never be a \"black box.\" Here, we solve the world's most common network pain points with hardened, production-ready code\u2014explained line-by-line so you can deploy with total confidence.</p>","tags":["Home","Python","Cisco","Network Automation","Netmiko"]},{"location":"#quick-navigation","title":"\ud83d\ude80 Quick Navigation","text":"New Here?Learn Python AutomationDeploy Pre-Built ToolsNeed Custom Solutions? <p>Get Started with our onboarding guide.</p> <p>Learn what Nautomation Prime offers and which path is right for you.</p> <p>Technical Deep Dives teach you the \"why\" behind production automation.</p> <p>Start with CDP Network Audit\u2014learn threading, security, and enterprise patterns.</p> <p>Script Library has production-ready automation.</p> <p>Tools are documented, hardened, and explained line-by-line.</p> <p>Services covers bespoke automation, portable bundles, and Docker containers.</p> <p>We build automation tailored to your specific topology.</p>","tags":["Home","Python","Cisco","Network Automation","Netmiko"]},{"location":"#what-we-offer","title":"What We Offer","text":"<p>Note: This site assumes you already know Python. We don\u2019t teach Python itself \u2014 we teach you how to understand, adapt, and extend our production\u2011grade automation scripts. If you\u2019re new to Python, complete a fundamentals course first, then return to explore the internals of our tooling.  </p>","tags":["Home","Python","Cisco","Network Automation","Netmiko"]},{"location":"#deep-dives","title":"\ud83d\udcd6 Deep Dives","text":"<p>Detailed walkthroughs of production Python scripts. We explain the logic, the libraries, the safety checks, and the engineering decisions behind every line.</p> <p>Featured: CDP Network Audit Tool \u2014 Multi-threaded topology discovery with hardened security</p>","tags":["Home","Python","Cisco","Network Automation","Netmiko"]},{"location":"#script-library","title":"\ud83d\udcda Script Library","text":"<p>Open-source, production-ready automation tools for Cisco infrastructure.</p> <p>Available: CDP Network Audit, Access Switch Audit Coming Soon: IOS-XE Upgrade Orchestrator, Zero Touch Provisioning (ZTP)</p>","tags":["Home","Python","Cisco","Network Automation","Netmiko"]},{"location":"#scheduled-automation-docker","title":"\ud83d\udc33 Scheduled Automation (Docker)","text":"<p>Pre-built containers for continuous network oversight. Daily config audits, health checks, and automated reporting\u2014no human intervention needed.</p>","tags":["Home","Python","Cisco","Network Automation","Netmiko"]},{"location":"#zero-install-bundles","title":"\ud83d\ude80 Zero-Install Bundles","text":"<p>No Python installed? No problem. Portable, \"plug-and-play\" bundles run on Windows and Linux without installation or admin rights. Full source code included.</p>","tags":["Home","Python","Cisco","Network Automation","Netmiko"]},{"location":"#bespoke-services","title":"\ud83d\udee0\ufe0f Bespoke Services","text":"<p>Custom solutions tailored to your topology. Expert consultancy for Zero Trust deployment, bulk provisioning, ISE automation, and more.</p>","tags":["Home","Python","Cisco","Network Automation","Netmiko"]},{"location":"#the-prime-philosophy","title":"The \"Prime\" Philosophy","text":"<p>Every tool and guide adheres to three core principles:</p> Principle What It Means Line-by-Line Transparency We explain the why behind the code, not just the what. Every design decision is documented. Hardened for Production Robust error handling, pre-flight safety checks, enterprise credential management, and thread-safe operations. Vendor-Neutral Built on industry-standard libraries (Netmiko, Nornir, PyATS). Your skills remain portable.","tags":["Home","Python","Cisco","Network Automation","Netmiko"]},{"location":"#ready-to-get-started","title":"Ready to Get Started?","text":"<ul> <li>New to Nautomation Prime? \u2192 Getting Started Guide for philosophy and pathways</li> <li>Want to Learn? \u2192 Technical Deep Dives for production-grade walkthroughs</li> <li>Ready to Deploy? \u2192 Script Library or explore Services</li> <li>Have Questions? \u2192 Check Getting Started FAQ or contact us via email or LinkedIn</li> </ul> <p>Mission: To empower engineers through Python-driven transparency and provide enterprises with hardened automation that eliminates error and accelerates growth.</p>","tags":["Home","Python","Cisco","Network Automation","Netmiko"]},{"location":"about/","title":"About Nautomation Prime","text":"","tags":["About","Company","Contact"]},{"location":"about/#our-story","title":"Our Story","text":"<p>Nautomation Prime was founded to bridge the gap between complex Cisco infrastructure and accessible Python-driven automation. We believe network engineers deserve transparency in their automation tools\u2014no black boxes, no mystery code, just clear, production-ready solutions explained line-by-line.</p>","tags":["About","Company","Contact"]},{"location":"about/#what-we-do","title":"What We Do","text":"<p>We provide three core services:</p>","tags":["About","Company","Contact"]},{"location":"about/#education","title":"\ud83c\udf93 Education","text":"<p>Free, comprehensive technical guides (Deep Dives) that teach network automation through real-world Cisco use cases. Every script is explained line-by-line, every design decision documented.</p>","tags":["About","Company","Contact"]},{"location":"about/#open-source-tools","title":"\ud83d\udee0\ufe0f Open-Source Tools","text":"<p>Production-hardened Python scripts for common network automation tasks: - CDP Network Audit - Access Switch Port Audit - Zero Touch Provisioning (ZTP) \u2014 Coming Soon - IOS-XE Upgrade Orchestrator \u2014 Coming Soon</p> <p>All tools are available on GitHub under GPL-3.0 licence.</p>","tags":["About","Company","Contact"]},{"location":"about/#professional-services","title":"\ud83d\udcbc Professional Services","text":"<p>Bespoke automation solutions tailored to your specific topology: - Custom Python scripting - Portable bundles for restricted environments - Docker containers for continuous automation - ISE and Zero Trust automation</p>","tags":["About","Company","Contact"]},{"location":"about/#our-philosophy","title":"Our Philosophy","text":"<p>Every tool, guide, and service adheres to three core principles:</p>","tags":["About","Company","Contact"]},{"location":"about/#1-line-by-line-transparency","title":"1. Line-by-Line Transparency","text":"<p>We explain the why behind the code, not just the what. Every design decision is documented so you understand your automation completely.</p>","tags":["About","Company","Contact"]},{"location":"about/#2-hardened-for-production","title":"2. Hardened for Production","text":"<p>Robust error handling, pre-flight safety checks, enterprise credential management, and thread-safe operations. These aren't \"nice to have\"\u2014they're essential for critical infrastructure.</p>","tags":["About","Company","Contact"]},{"location":"about/#3-vendor-neutral","title":"3. Vendor-Neutral","text":"<p>Built on industry-standard libraries (Netmiko, Nornir, PyATS). Your skills remain portable across vendors and platforms.</p>","tags":["About","Company","Contact"]},{"location":"about/#the-team","title":"The Team","text":"<p>Christopher Davies - Founder &amp; Principal Automation Engineer</p> <p>Christopher specialises in enterprise Cisco automation, with deep expertise in Python, ISE, and Zero Trust architectures. His mission is to democratise network automation through transparency and education.</p> <p>Trading Status: Christopher Davies trading as (T/A) Nautomation Prime</p> <p>Connect on LinkedIn</p>","tags":["About","Company","Contact"]},{"location":"about/#technology-stack","title":"Technology Stack","text":"<p>Our tools and guides leverage industry-standard Python libraries:</p> <ul> <li>Netmiko - Multi-vendor SSH automation</li> <li>Paramiko - Low-level SSH protocol implementation</li> <li>Nornir - Multi-threaded automation framework</li> <li>TextFSM - Structured parsing of CLI output</li> <li>Pandas &amp; OpenPyXL - Professional Excel reporting</li> <li>PyATS - Cisco test automation framework</li> </ul>","tags":["About","Company","Contact"]},{"location":"about/#open-source-commitment","title":"Open Source Commitment","text":"<p>All public repositories are licenced under GNU GPL-3.0, ensuring: - Source code transparency - Community contributions welcome - Free for educational and commercial use - Copyleft protection</p> <p>Bespoke client code is licenced under MIT or Apache 2.0 as agreed during engagement.</p> <p>View Licensing Details</p>","tags":["About","Company","Contact"]},{"location":"about/#get-involved","title":"Get Involved","text":"","tags":["About","Company","Contact"]},{"location":"about/#use-our-tools","title":"Use Our Tools","text":"<p>Browse the Script Library and start automating today.</p>","tags":["About","Company","Contact"]},{"location":"about/#learn-network-automation","title":"Learn Network Automation","text":"<p>Explore our Technical Deep Dives for comprehensive guides.</p>","tags":["About","Company","Contact"]},{"location":"about/#request-custom-solutions","title":"Request Custom Solutions","text":"<p>Need bespoke automation? Contact us to discuss your requirements.</p>","tags":["About","Company","Contact"]},{"location":"about/#contribute","title":"Contribute","text":"<p>Found a bug or have a feature request? Open an issue on our GitHub organisation.</p>","tags":["About","Company","Contact"]},{"location":"about/#contact","title":"Contact","text":"<p>Geographic Address (UK): Christopher Davies T/A Nautomation Prime 9 The Sleeve Leek, ST138 HR Staffordshire England United Kingdom</p> <ul> <li>Email: nautomationprime.f3wfe@simplelogin.com</li> <li>LinkedIn: Nautomation Prime Company Page</li> <li>GitHub: Nautomation-Prime Organisation</li> </ul>","tags":["About","Company","Contact"]},{"location":"about/#legal","title":"Legal","text":"<ul> <li>Privacy Policy</li> <li>Terms of Use</li> <li>Disclaimer</li> <li>Licensing</li> <li>Brand &amp; Logo Usage</li> </ul> <p>Mission: To empower engineers through Python-driven transparency and provide enterprises with hardened automation that eliminates error and accelerates growth.</p>","tags":["About","Company","Contact"]},{"location":"getting-started/","title":"Getting Started with Nautomation Prime","text":"<p>Welcome! This guide will help you understand what Nautomation Prime offers and how to get started.</p>","tags":["Getting Started","Guide","Tutorial","Onboarding"]},{"location":"getting-started/#what-is-nautomation-prime","title":"What is Nautomation Prime?","text":"<p>Nautomation Prime bridges the gap between complex Cisco infrastructure and streamlined Python-driven automation. We provide:</p> <ul> <li>Production-ready automation scripts explained line-by-line</li> <li>Deep-dive technical guides that teach you the \"why\" behind the code</li> <li>Enterprise solutions including Docker containers and portable bundles</li> <li>Bespoke services for custom automation needs</li> </ul> <p>Important: This site is not a Python tutorial. We assume you already know Python basics (variables, functions, loops, exceptions, file I/O). Our goal is to teach you how to apply Python to network automation and provide a foundation you can transfer into your own scripts or learning journey.</p>","tags":["Getting Started","Guide","Tutorial","Onboarding"]},{"location":"getting-started/#quick-start-paths","title":"\ud83d\ude80 Quick Start Paths","text":"","tags":["Getting Started","Guide","Tutorial","Onboarding"]},{"location":"getting-started/#i-want-to-learn-network-automation","title":"I want to learn network automation","text":"<p>Start with our Technical Deep Dives. We provide comprehensive guides that explain Python automation concepts alongside real Cisco use cases.</p> <p>Recommended Reading Order: 1. CDP Network Audit Deep Dive - Learn about threading, security, and production-grade design</p>","tags":["Getting Started","Guide","Tutorial","Onboarding"]},{"location":"getting-started/#i-want-to-use-pre-built-scripts","title":"I want to use pre-built scripts","text":"<p>Check out our Script Library. Each script comes with documentation and GitHub repositories for easy deployment.</p> <p>Popular Scripts: - CDP Network Audit Tool - Discover your Cisco topology with line-by-line transparency</p>","tags":["Getting Started","Guide","Tutorial","Onboarding"]},{"location":"getting-started/#i-need-custom-automation-for-my-environment","title":"I need custom automation for my environment","text":"<p>Explore our Services page. We offer: - Custom Python scripting tailored to your topology - Portable bundles for restricted environments - Docker containers for continuous automation - ISE and Zero Trust automation</p>","tags":["Getting Started","Guide","Tutorial","Onboarding"]},{"location":"getting-started/#prerequisites","title":"\ud83d\udccb Prerequisites","text":"<p>Python Knowledge (Important!): - This site assumes you already know Python. We teach you how to apply Python to network automation, not how to learn Python itself. - If you're new to Python, we recommend completing a Python fundamentals course first (Codecademy, Real Python, W3Schools, or similar). - You should understand: variables, functions, loops, conditionals, exceptions, and basic file I/O. - Our code is written for clarity (not brevity), so intermediate Python developers will follow along easily.</p> <p>Technical Requirements: - Python 3.8+ (or use our portable bundles if Python isn't available) - Network access to your Cisco devices - Credentials for device authentication - SSH enabled on target Cisco devices</p>","tags":["Getting Started","Guide","Tutorial","Onboarding"]},{"location":"getting-started/#security-credentials","title":"\ud83d\udd10 Security &amp; Credentials","text":"<p>Nautomation Prime follows enterprise security best practices:</p> <p>\u2705 Credentials stored in OS credential managers (not plaintext files) \u2705 No hardcoded secrets in scripts \u2705 Secure jump-host support for isolated networks \u2705 Full source code transparency (no compiled binaries)</p>","tags":["Getting Started","Guide","Tutorial","Onboarding"]},{"location":"getting-started/#core-concepts","title":"\ud83d\udcda Core Concepts","text":"","tags":["Getting Started","Guide","Tutorial","Onboarding"]},{"location":"getting-started/#the-prime-philosophy","title":"The \"Prime\" Philosophy","text":"<p>Every tool, script, and guide adheres to three principles:</p> <ol> <li>Line-by-Line Transparency</li> <li>We explain the why behind the code, not just the what</li> <li>Every design decision is documented</li> <li> <p>You'll understand your automation, not just run it</p> </li> <li> <p>Hardened for Production</p> </li> <li>Robust error handling</li> <li>Pre-flight safety checks</li> <li>Enterprise-grade credential management</li> <li> <p>Thread-safe concurrent operations</p> </li> <li> <p>Vendor-Neutral</p> </li> <li>Built on industry-standard libraries (Netmiko, Nornir, PyATS)</li> <li>Your skills remain portable</li> <li>Scripts can scale beyond Cisco if needed</li> </ol>","tags":["Getting Started","Guide","Tutorial","Onboarding"]},{"location":"getting-started/#common-tasks","title":"\ud83d\udee0\ufe0f Common Tasks","text":"","tags":["Getting Started","Guide","Tutorial","Onboarding"]},{"location":"getting-started/#deploy-the-cdp-network-audit-tool","title":"Deploy the CDP Network Audit Tool","text":"<ol> <li>Visit the CDP Audit GitHub repository</li> <li>Read the Deep Dive guide for understanding the architecture</li> <li>Follow the README for installation and configuration</li> <li>Run your first discovery against a test device</li> </ol>","tags":["Getting Started","Guide","Tutorial","Onboarding"]},{"location":"getting-started/#request-custom-automation","title":"Request Custom Automation","text":"<ol> <li>Document your use case and network topology</li> <li>Contact us via email or LinkedIn</li> <li>Describe any constraints (e.g., restricted environments, specific platforms)</li> <li>Receive a detailed proposal and timeline</li> </ol>","tags":["Getting Started","Guide","Tutorial","Onboarding"]},{"location":"getting-started/#use-portable-bundles-no-python-installation","title":"Use Portable Bundles (No Python Installation)","text":"<ol> <li>Request a custom bundle through our services page</li> <li>Download the bundle to your workstation or USB drive</li> <li>Extract and run directly\u2014no installation needed</li> <li>Full source code is included for auditing</li> </ol>","tags":["Getting Started","Guide","Tutorial","Onboarding"]},{"location":"getting-started/#frequently-asked-questions","title":"\u2753 Frequently Asked Questions","text":"<p>Q: Do I need Python installed to use Nautomation Prime tools? A: Not necessarily! We offer portable bundles that run without Python installation. Ideal for restricted enterprise environments where Python may not be permitted.</p> <p>Q: Can you automate my specific network topology? A: Absolutely! Our bespoke services cover custom scripting for any topology. Contact us via email or LinkedIn to discuss your specific requirements.</p> <p>Q: Are these tools vendor-locked to Cisco? A: Our tools are built on vendor-neutral libraries like Netmiko and Nornir. While designed for Cisco, the patterns and concepts apply across other vendors (Juniper, Arista, etc.).</p> <p>Q: How do I secure my credentials? A: We leverage native OS credential managers (Windows Credential Manager, Keychain on macOS, pass on Linux). Passwords are never stored in plaintext files or hardcoded in scripts. When you run a script like CDP Network Audit for the first time, it will prompt you to save your credentials to Windows Credential Manager\u2014just enter your username and password, and the script will store them securely. Future runs will use the stored credentials automatically.</p> <p>Q: What about support and updates? A: All tools are maintained on GitHub with active development. Issues and feature requests can be filed directly on repositories. For enterprise support, contact us.</p>","tags":["Getting Started","Guide","Tutorial","Onboarding"]},{"location":"getting-started/#next-steps","title":"\ud83d\udcd6 Next Steps","text":"<ul> <li>Learn: Dive into a Deep Dive</li> <li>Deploy: Browse the Script Library</li> <li>Build: Explore Services for custom solutions</li> <li>Connect: Contact us via email or LinkedIn</li> </ul> <p>Our Mission: To empower engineers through Python-driven transparency and provide enterprises with hardened automation that eliminates error and accelerates growth.</p>","tags":["Getting Started","Guide","Tutorial","Onboarding"]},{"location":"services/","title":"Bespoke Automation Services","text":"","tags":["Services","Consulting","Custom Automation","ISE","Docker"]},{"location":"services/#precision-python-solutions-for-cisco-infrastructure","title":"Precision Python Solutions for Cisco Infrastructure","text":"<p>At Nautomation Prime, we bridge the gap between complex infrastructure and streamlined Python-driven automation. We provide hardened, production-ready logic designed to eliminate manual error and scale your network operations.</p>","tags":["Services","Consulting","Custom Automation","ISE","Docker"]},{"location":"services/#what-we-solve","title":"What We Solve","text":"","tags":["Services","Consulting","Custom Automation","ISE","Docker"]},{"location":"services/#custom-python-scripting","title":"\ud83d\udee0\ufe0f Custom Python Scripting","text":"<p>We build bespoke tools tailored to your specific topology. We don't just provide code; we provide transparency. * Automated Provisioning: Scripts for bulk VLAN, SVI, and Interface configurations. * Fleet Upgrades: Intelligent Python workflows for IOS and IOS-XE software management. * Compliance Auditing: Automated \"Golden Config\" verification against your enterprise standards.</p>","tags":["Services","Consulting","Custom Automation","ISE","Docker"]},{"location":"services/#zero-install-deployment-portable-bundles","title":"\ud83d\ude80 Zero-Install Deployment (Portable Bundles)","text":"<p>We understand that enterprise workstations are often restricted. Our custom solutions can be delivered as Portable Python Bundles. * No Installation Required: Run our automation tools directly from a folder or USB drive without needing to install Python on the local machine. * Full Transparency: Unlike compiled binaries, our bundles keep the source code visible and auditable, maintaining our commitment to \"Line-by-Line\" clarity. * Self-Contained: All required libraries (Netmiko, Nornir, etc.) are pre-packaged within the bundle for a \"plug-and-play\" experience.  </p>","tags":["Services","Consulting","Custom Automation","ISE","Docker"]},{"location":"services/#api-security-automation-ise","title":"\ud83d\udd10 API &amp; Security Automation (ISE)","text":"<p>Streamline your Zero Trust architecture through programmatic control. * Identity Services Engine (ISE): Automation of SGT assignments and endpoint profiling via the ERS/OpenAPI. * Automated Policy Enforcement: Logic-based ACL generation and deployment.  </p>","tags":["Services","Consulting","Custom Automation","ISE","Docker"]},{"location":"services/#network-visibility","title":"\ud83d\udcca Network Visibility","text":"<p>Turn CLI data into actionable insights with custom Python parsers. * Automated Reporting: Generate real-time audits for inventory and compliance. * Topology Intelligence: Discovery scripts that map your physical and logical layers.  </p>","tags":["Services","Consulting","Custom Automation","ISE","Docker"]},{"location":"services/#scheduled-automation","title":"\ud83d\udc33 Scheduled \"Appliance\" Containers (Docker)","text":"<p>For enterprises looking for continuous oversight, we provide pre-built Docker containers designed for autonomous execution. * Scheduled Auditing: Automate \"Golden Config\" checks or security scans to run daily or weekly without human intervention. * Health Monitoring: Containers that periodically poll Cisco ISE or IOS-XE devices to alert you to anomalies before they become outages. * Zero-Touch Maintenance: Our containers come pre-configured with the necessary Python environments and logic\u2014just pull, run, and let the automation work for you.</p>","tags":["Services","Consulting","Custom Automation","ISE","Docker"]},{"location":"services/#why-choose-nautomation-prime","title":"Why Choose Nautomation Prime?","text":"<p>Our engagement model is built on three core commitments:</p> Commitment What This Means Line-by-Line Transparency Every script includes detailed explanations. You understand your automation, not just run it. Hardened for Enterprise Production-grade error handling, pre-flight validation, and security best practices\u2014not shortcuts. Vendor-Neutral Built on Netmiko, Nornir, and PyATS. Your skills remain portable beyond Cisco.","tags":["Services","Consulting","Custom Automation","ISE","Docker"]},{"location":"services/#investment-engagement-model","title":"Investment &amp; Engagement Model","text":"","tags":["Services","Consulting","Custom Automation","ISE","Docker"]},{"location":"services/#how-we-price-bespoke-automation","title":"How We Price Bespoke Automation","text":"<p>Nautomation Prime operates on a fixed-fee project basis\u2014you receive a detailed scope, deliverables list, and total cost estimate upfront. No hourly billing, no surprise invoices, no scope creep.</p> <p>This model protects both parties: you gain budget certainty, and we're incentivised to deliver efficient, well-architected solutions rather than dragging out billable hours.</p>","tags":["Services","Consulting","Custom Automation","ISE","Docker"]},{"location":"services/#what-influences-project-cost","title":"What Influences Project Cost?","text":"<p>Every engagement is scoped individually, but pricing is typically determined by:</p> Factor Impact on Scope Device Count A 50-device access layer audit has different complexity than a 500-device campus. Infrastructure Complexity Legacy IOS vs. modern IOS-XE, and distributed topologies require additional validation logic. Deliverable Type A standalone Python script is a different engagement than a Dockerised container with Grafana dashboards. Integration Requirements Connecting to ISE, ServiceNow, or your CMDB adds development and testing overhead. Documentation Depth Line-by-line code explanations (our standard) vs. operational runbooks vs. full knowledge transfer workshops.","tags":["Services","Consulting","Custom Automation","ISE","Docker"]},{"location":"services/#typical-project-ranges","title":"Typical Project Ranges","text":"<p>To give you a sense of scale (all prices exclude VAT):</p> <ul> <li>Simple Automation Script (e.g., single-device configuration audit, basic VLAN provisioning): \u00a31,200\u2013\u00a32,500</li> <li>Medium Complexity Tool (e.g., multi-threaded inventory collection with Excel reporting for 50+ devices): \u00a33,000\u2013\u00a35,500</li> <li>Enterprise-Grade Solution (e.g., multi-threaded CDP topology mapper, ISE SGT automation, portable Docker containers with full documentation): \u00a36,000\u2013\u00a312,000+</li> </ul> <p>These are indicative ranges\u2014actual quotes depend on your specific requirements. A detailed scope call is always free.</p>","tags":["Services","Consulting","Custom Automation","ISE","Docker"]},{"location":"services/#why-fixed-fee-pricing-works-for-network-automation","title":"Why Fixed-Fee Pricing Works for Network Automation","text":"<p>For You: - Predictable budgets for finance and procurement teams - No incentive for inefficiency\u2014we're motivated to deliver clean, maintainable code - Single invoice per project phase\u2014simpler accounting</p> <p>For Us: - Rewards engineering excellence\u2014the better our architecture, the more efficient our delivery - Encourages reusable components\u2014we build smarter over time - Aligns with our philosophy\u2014\"Line-by-Line Transparency\" means we document once, properly</p>","tags":["Services","Consulting","Custom Automation","ISE","Docker"]},{"location":"services/#the-roi-case-for-python-automation","title":"The ROI Case for Python Automation","text":"<p>Industry research consistently shows Python-driven network automation delivers measurable returns:</p> <p>Cisco &amp; ACG Study (2023): Mature automation deployments achieve 55% OPEX reduction in network operations.</p>","tags":["Services","Consulting","Custom Automation","ISE","Docker"]},{"location":"services/#what-does-this-mean-for-your-team","title":"What Does This Mean for Your Team?","text":"<p>Consider a mid-sized UK enterprise with 200 Cisco devices:</p> <ul> <li>Manual provisioning time: ~15 minutes per device for VLAN/SVI changes \u00d7 50 changes/year = 125 hours</li> <li>Compliance audits: Manual \"golden config\" checks across 200 devices quarterly = 80 hours/year</li> <li>Incident response: CLI data gathering during outages = 40 hours/year (conservative)</li> </ul> <p>Total: 245 hours of repetitive engineering work annually.</p> <p>At an average senior engineer cost of \u00a350/hour (internal cost, not salary), that's \u00a312,250/year in manual effort. A \u00a36,000 automation investment pays for itself in 6 months, then delivers savings every year thereafter.</p> <p>Beyond cost, you gain: - Elimination of human error in production changes - Audit trails for compliance and security teams - Instant runbooks embedded in the code itself - Faster incident response\u2014data gathering in seconds, not hours</p>","tags":["Services","Consulting","Custom Automation","ISE","Docker"]},{"location":"services/#what-you-receive-in-every-engagement","title":"What You Receive in Every Engagement","text":"<p>Regardless of project size, all deliverables include:</p> <p>\u2705 Production-hardened Python code with enterprise-grade error handling \u2705 Line-by-line documentation explaining every design decision \u2705 Pre-flight validation logic to prevent misconfigurations before deployment \u2705 Comprehensive README with installation, usage, and troubleshooting guides \u2705 Example inventory files tailored to your environment \u2705 Post-delivery support window (typically 30 days for bug fixes and adjustments)</p> <p>Optional add-ons available: - Knowledge transfer workshops (remote or on-site) - CI/CD pipeline integration (GitHub Actions, GitLab CI, Jenkins) - Custom Grafana/Prometheus dashboards for scheduled automation containers - Extended support contracts for ongoing maintenance</p>","tags":["Services","Consulting","Custom Automation","ISE","Docker"]},{"location":"services/#the-engagement-process","title":"The Engagement Process","text":"<ol> <li> <p>Discovery Call (30\u201360 minutes, free)    We discuss your pain points, topology, and automation goals. No obligation.</p> </li> <li> <p>Scope &amp; Proposal (delivered within 5 business days)    Detailed project plan with deliverables, timeline, and fixed-fee quote.</p> </li> <li> <p>Agreement &amp; Kickoff    Once approved, we schedule a technical deep-dive to gather inventory, credentials (securely), and validation criteria.</p> </li> <li> <p>Development &amp; Testing (typical turnaround: 2\u20134 weeks for medium projects)    You receive progress updates and can request checkpoint reviews.</p> </li> <li> <p>Delivery &amp; Handover    Final code, documentation, and a walkthrough session. Your team gains full ownership and understanding.</p> </li> <li> <p>Support Window (30 days post-delivery)    Bug fixes and minor adjustments included. Feature additions quoted separately.</p> </li> </ol>","tags":["Services","Consulting","Custom Automation","ISE","Docker"]},{"location":"services/#about-nautomation-prime","title":"About Nautomation Prime","text":"<p>We are a UK-based, specialist network automation consultancy focused exclusively on Cisco infrastructure and Python-driven solutions. </p> <p>As a boutique practice, you work directly with the principal engineer on every engagement\u2014no junior developers, no outsourcing, no knowledge loss between \"sales\" and \"delivery.\" You get senior-level expertise from discovery through to production deployment.</p> <p>Credentials &amp; Compliance: - VAT-registered UK business (VAT number provided on invoices) - Professional Indemnity &amp; Public Liability Insurance - GDPR-compliant data handling (see Privacy Policy) - All client code licenced under MIT or Apache 2.0 (your choice)</p>","tags":["Services","Consulting","Custom Automation","ISE","Docker"]},{"location":"services/#get-started-today","title":"Get Started Today","text":"<p>Ready to eliminate manual error and accelerate your network operations?</p> <p>Request a Free Scope Call to discuss your automation needs.</p> <p>Typical response time: within 24 to 48 hours (UK business days).</p> <p>Mission: To empower engineers through Python-driven transparency and provide enterprises with hardened automation that eliminates error and accelerates growth.</p>","tags":["Services","Consulting","Custom Automation","ISE","Docker"]},{"location":"coming-soon/","title":"Coming Soon","text":"<p>Welcome to the Coming Soon section! This area showcases automation projects currently in the design and planning phase. These comprehensive solutions are being carefully architected to address real-world network engineering challenges.</p>","tags":["Coming Soon","Roadmap"]},{"location":"coming-soon/#what-to-expect","title":"What to Expect","text":"<p>The scripts and tools featured here represent:</p> <ul> <li>Detailed Design Documents - Comprehensive planning blueprints covering architecture, workflows, and implementation strategies</li> <li>Best Practices - Industry-standard approaches to common network automation challenges</li> <li>Platform-Specific Guidance - Tailored solutions for Cisco IOS, IOS-XE, NX-OS, and other platforms</li> <li>Production-Ready Planning - Enterprise-grade considerations for fault tolerance, security, and scalability</li> </ul>","tags":["Coming Soon","Roadmap"]},{"location":"coming-soon/#projects-in-development","title":"Projects in Development","text":"","tags":["Coming Soon","Roadmap"]},{"location":"coming-soon/#ios-xe-software-upgrade-orchestrator","title":"IOS-XE Software Upgrade Orchestrator","text":"<p>A comprehensive Python-based orchestration framework for automating Cisco IOS-XE software upgrades across diverse platforms. This design document covers:</p> <ul> <li>End-to-end upgrade workflows (discovery, validation, execution, rollback)</li> <li>Platform-specific considerations (ISSU, dual SUPs, StackWise Virtual)</li> <li>Fault tolerance and error handling strategies</li> <li>Integration with Excel-based inventory and existing automation tools</li> <li>Security, compliance, and audit trail requirements</li> </ul> <p>Status:  Design &amp; Planning Phase</p>","tags":["Coming Soon","Roadmap"]},{"location":"coming-soon/#stay-updated","title":"Stay Updated","text":"<p>These projects will be promoted to the Script Library once implementation is complete and thoroughly tested. Check back regularly for updates!</p> <p>Feedback Welcome</p> <p>Have suggestions or specific requirements for these upcoming tools? Feel free to reach out via the contact page.</p>","tags":["Coming Soon","Roadmap"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/","title":"Design and Planning Document: Cisco IOS-XE Software Upgrade Orchestrator","text":"<p>Project Status: Design &amp; Planning Phase</p> <p>This document represents the comprehensive design blueprint for an upcoming automation tool. Implementation is currently in the planning stage.</p>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#quick-reference","title":"Quick Reference","text":"<p>Jump to Section:</p> <ul> <li>High-Level Architecture - System components and design philosophy</li> <li>Workflow Stages - End-to-end upgrade process breakdown</li> <li>Platform-Specific Handling - ISSU, dual SUPs, StackWise considerations</li> <li>Rollback Mechanisms - Recovery strategies and procedures</li> <li>Security Considerations - Credential management and access controls</li> <li>Module Breakdown - Detailed component architecture</li> </ul>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#introduction","title":"Introduction","text":"<p>Upgrading Cisco IOS-XE devices is a critical, high-stakes operation for enterprise and service provider networks. The process is fraught with complexity, risk, and platform-specific nuances. Manual upgrades are time-consuming, error-prone, and difficult to scale. Automation is essential for maintaining network security, stability, and compliance, especially as device fleets grow and maintenance windows shrink. This document presents a comprehensive design and planning blueprint for a Python-based \"IOS-XE Software Upgrade Orchestrator.\" The orchestrator aims to automate the end-to-end upgrade process for Cisco IOS-XE devices, supporting image validation, pre-checks, image transfer, upgrade execution, post-checks, and robust rollback mechanisms. The design emphasizes modularity, fault tolerance, scalability, and integration with an Excel-driven source-of-truth and CLI-based operator workflows.</p>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#high-level-architecture","title":"High-Level Architecture","text":"","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#architectural-overview","title":"Architectural Overview","text":"<p>The orchestrator is conceived as a modular, extensible Python application capable of orchestrating upgrades across diverse IOS-XE platforms (Catalyst 9k, ISR, ASR, NCS, etc.). It interfaces with devices via SSH/CLI, leverages an Excel (or CSV) file as the authoritative inventory and configuration source, and supports integration with existing automation frameworks (e.g., Ansible, Netmiko, Nornir).</p> <p>Key architectural components: - Inventory and State Management Layer: Reads and writes device inventory, upgrade status, and configuration data from/to Excel or a similar source-of-truth. - Device Abstraction Layer: Encapsulates platform-specific logic and provides a uniform interface for device operations. - Workflow Engine: Orchestrates the upgrade process, managing workflow stages, error handling, and operator interactions. - Transport and Execution Layer: Handles CLI connections, command execution, and file transfers (SCP, TFTP, HTTP). - Logging and Observability Layer: Provides detailed logging, telemetry, and audit trails for compliance and troubleshooting. - Operator Interaction Layer: Supports CLI-based prompts, approvals, and rollback triggers, enabling human-in-the-loop workflows.  </p> <p>Textual Architecture Diagram Description:</p> <pre><code>+-------------------------------------------------------------+\n|                IOS-XE Software Upgrade Orchestrator         |\n+-------------------------------------------------------------+\n|  [Inventory/State] &lt;--&gt; [Workflow Engine] &lt;--&gt; [Operator]   |\n|         |                        |                |         |\n|         v                        v                v         |\n|  [Device Abstraction] &lt;--&gt; [Transport/Exec] &lt;--&gt; [Logging]  |\n+-------------------------------------------------------------+\n|                  [External Integrations]                    |\n|   (Ansible, Netmiko, Nornir, DNA Center, Excel, Git, etc.)  |\n+-------------------------------------------------------------+\n</code></pre> <p>This layered approach ensures separation of concerns, extensibility, and maintainability. Each module can be independently developed, tested, and replaced as requirements evolve.</p>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#workflow-stages-end-to-end-upgrade-process","title":"Workflow Stages: End-to-End Upgrade Process","text":"<p>A robust upgrade orchestrator must implement a well-defined, repeatable workflow. Each stage is designed to be idempotent, fault-tolerant, and capable of handling partial failures or retries.</p>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#1-discovery-and-inventory","title":"1. Discovery and Inventory","text":"<p>Purpose: Identify target devices, gather current state, and validate readiness for upgrade.</p> <ul> <li>Inventory Source: Devices and upgrade parameters are sourced from an Excel file (or CSV/DB), which acts as the single source-of-truth (SoT).</li> <li>Discovery Mechanisms: Use CDP/LLDP, SNMP, or CLI-based discovery to validate device reachability and gather hardware/software details.</li> <li>State Collection: Collect current software version, boot mode (install vs. bundle), available flash space, redundancy status (dual SUPs, StackWise), and platform type.</li> </ul> <p>Best Practices: - Ensure inventory is up-to-date and validated against live device data. - Use unique device identifiers (hostname, serial, management IP) to avoid ambiguity. - Maintain upgrade state and history in the source-of-truth for auditability.</p> <p>Common Pitfalls</p> <ul> <li>Stale or inconsistent inventory data leading to missed or duplicate upgrades.</li> <li>Incomplete discovery of stack members or redundant supervisors.</li> </ul>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#2-image-selection-and-validation","title":"2. Image Selection and Validation","text":"<p>Purpose: Select the appropriate IOS-XE image, validate compatibility, and ensure integrity.</p> <ul> <li>Image Selection: Choose image based on platform, desired version (preferably LTS for stability), and compatibility with hardware modules.</li> <li>Compatibility Checks: Cross-reference Cisco release notes for memory, hardware, and feature compatibility.</li> <li>Integrity Verification: Validate image using MD5/SHA2 checksums before and after transfer.</li> <li>Image Repository: Support local, network (SCP/TFTP/HTTP), or cloud-based image repositories.</li> </ul> <p>Best Practices: - Always use images downloaded from Cisco.com and verify cryptographic hashes. - Maintain a catalog of approved images and their checksums in the source-of-truth. - Automate compatibility checks using structured release note data where possible.</p> <p>Common Pitfalls</p> <ul> <li>Skipping hash verification, leading to device boot failures due to corrupt images.</li> <li>Selecting images incompatible with hardware or feature requirements.</li> </ul>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#3-pre-upgrade-checks","title":"3. Pre-Upgrade Checks","text":"<p>Purpose: Assess device health, backup configurations, and ensure upgrade prerequisites are met.</p> <ul> <li>Health Checks: Verify device uptime, CPU/memory utilization, interface/link status, and redundancy state.</li> <li>Backup: Save running and startup configurations, current image, and critical logs to a remote server (TFTP/SCP/FTP).</li> <li>Flash Space: Check available storage and remove inactive packages if necessary.</li> <li>Redundancy/HA: Confirm stateful switchover (SSO) readiness for dual SUPs or StackWise Virtual.</li> <li>Maintenance Window: Validate that upgrade is scheduled within an approved window.</li> </ul> <p>Best Practices: - Automate pre-checks and halt the workflow if any critical check fails. - Store backups with clear naming conventions and timestamps for easy retrieval. - Document all pre-check results for compliance and troubleshooting.</p> <p>Common Pitfalls</p> <ul> <li>Insufficient flash space causing upgrade failures.</li> <li>Missing configuration backups, complicating recovery from failed upgrades.</li> </ul>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#4-image-transfer","title":"4. Image Transfer","text":"<p>Purpose: Reliably transfer the validated image to the device using secure and efficient protocols.</p> <ul> <li>Supported Protocols: SCP (preferred for security), SFTP, FTP, TFTP, HTTP/HTTPS.</li> <li>Transfer Validation: Verify image integrity post-transfer using hash checks.</li> <li>Parallelization: For large-scale upgrades, batch transfers to avoid network congestion.</li> </ul> <p>Comparison Table: Image Transfer Methods</p> Protocol Security Speed Authentication Use Case SCP High Fast Yes Preferred for secure envs SFTP High Medium Yes Secure, slower than SCP FTP Low Medium Yes Legacy, avoid if possible TFTP None Fast No Simple, not secure HTTP(S) High Fast Yes (HTTPS) Modern, scalable <p>Protocol Selection</p> <p>SCP and HTTPS are preferred for secure environments. TFTP is fast but insecure and should be avoided unless in isolated, trusted networks. Always verify image integrity after transfer.</p> <p>Best Practices: - Use SCP or HTTPS for all production upgrades. - Automate retries with exponential backoff in case of transient network failures. - Log transfer times and throughput for performance monitoring.</p> <p>Common Pitfalls</p> <ul> <li>Firewall or ACLs blocking transfer ports.</li> <li>Incomplete or interrupted transfers leading to corrupt images.</li> </ul>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#5-upgrade-execution","title":"5. Upgrade Execution","text":"<p>Purpose: Perform the actual software upgrade using platform-appropriate methods.</p> <ul> <li>Upgrade Modes: Support both Install Mode (recommended for Catalyst 9k and modern platforms) and Bundle Mode (legacy).</li> <li>Commands:</li> <li>Install Mode: <code>install add file ...</code>, <code>install activate</code>, <code>install commit</code></li> <li>Bundle Mode: Copy <code>.bin</code> to flash, update boot variable, reload</li> <li>Redundancy Handling: For dual SUPs or StackWise Virtual, coordinate upgrade steps to maintain HA and minimize downtime.</li> <li>ISSU Support: Where available, perform In-Service Software Upgrade to avoid traffic disruption (see ISSU vs. non-ISSU matrix below).</li> </ul> <p>Upgrade Method Comparison Table</p> Mode Platforms Downtime Complexity Rollback Support Notes Install Cat9k, ISR, ASR Low Medium Yes Preferred, modular Bundle Legacy, some ISR High Low Limited Simple, more downtime ISSU Cat9k (HA/SSO) Minimal High Yes Only within certain releases Non-ISSU All High Low Yes Requires reload <p>Best Practices: - Use Install Mode wherever possible for efficiency and rollback support. - Automate command execution and monitor for prompts or errors. - For stacks or dual SUPs, upgrade standby first, verify, then switchover.</p> <p>Common Pitfalls</p> <ul> <li>Boot variable misconfiguration leading to ROMmon boots.</li> <li>Stack member version mismatches causing split-brain scenarios.</li> </ul>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#6-post-upgrade-verification-and-health-checks","title":"6. Post-Upgrade Verification and Health Checks","text":"<p>Purpose: Confirm successful upgrade, device health, and service restoration.</p> <ul> <li>Version Check: Verify running version matches target.</li> <li>System Health: Check logs, interface/link status, routing, and protocol adjacencies.</li> <li>Redundancy: Confirm HA/SSO is re-established and all members are in sync.</li> <li>Service Validation: Run application-specific or customer-defined tests (e.g., ping, SNMP, traffic flows).</li> </ul> <p>Best Practices: - Automate post-checks and compare results to pre-upgrade baselines. - Document all verification steps and outcomes. - Rollback immediately if critical failures are detected.</p> <p>Common Pitfalls</p> <ul> <li>Overlooking subtle issues (e.g., missing licenses, feature regressions).</li> <li>Failing to validate all stack members or redundant supervisors.</li> </ul>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#7-rollback-and-recovery","title":"7. Rollback and Recovery","text":"<p>Purpose: Restore device to previous state in case of upgrade failure or post-upgrade issues.</p> <ul> <li>Rollback Mechanisms:</li> <li>Install Mode: Use <code>install rollback to committed</code> or set boot variable to previous image and reload.</li> <li>Bundle Mode: Set boot variable to previous <code>.bin</code> and reload.</li> <li>Configuration Rollback: Use configuration archives and <code>configure replace</code> to revert to known-good config.</li> <li>Trigger Conditions: Automated (failed health checks) or manual (operator approval).</li> <li>Rollback Verification: Confirm device is restored to previous version and operational state.</li> </ul> <p>Rollback Strategies Table</p> Rollback Type Supported Modes Downtime Automation Notes Install rollback Install Medium Yes Fast, preserves config Boot var revert All High Yes Requires reload, manual intervention Config replace All Low Yes For config errors, not image failures SMU rollback Install Medium Yes For patch-level rollbacks <p>Best Practices: - Always maintain backups of previous images and configurations. - Automate rollback triggers based on health check failures. - Document rollback events and root causes for continuous improvement.</p> <p>Critical: Common Pitfalls</p> <ul> <li>Removing previous images from flash, making rollback impossible.</li> <li>Incomplete rollback (e.g., config restored but image not).</li> </ul>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#modular-breakdown-key-components","title":"Modular Breakdown: Key Components","text":"<p>A modular design is essential for maintainability, extensibility, and testability. Each module should have a clear interface and responsibility.</p>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#1-inventory-and-state-management-module","title":"1. Inventory and State Management Module","text":"<ul> <li>Functions: Read/write device inventory, upgrade parameters, and state from Excel/CSV/DB.</li> <li>Features: Support for versioning, audit trails, and integration with external SoT systems (NetBox, Git, etc.).</li> <li>Edge Cases: Handle concurrent updates, partial failures, and data validation.</li> </ul>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#2-device-abstraction-module","title":"2. Device Abstraction Module","text":"<ul> <li>Functions: Encapsulate platform-specific logic (e.g., Catalyst 9k vs. ISR vs. ASR).</li> <li>Features: Device capability detection, command mapping, and error normalization.</li> <li>Edge Cases: Unsupported platforms, feature mismatches, or custom hardware modules.</li> </ul>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#3-workflow-engine-module","title":"3. Workflow Engine Module","text":"<ul> <li>Functions: Orchestrate upgrade workflow stages, manage state transitions, and handle retries.</li> <li>Features: Support for batching, parallel execution, and operator approvals.</li> <li>Edge Cases: Partial failures, idempotency, and workflow resumption after interruption.</li> </ul>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#4-transport-and-execution-module","title":"4. Transport and Execution Module","text":"<ul> <li>Functions: Manage CLI connections (SSH), command execution, and file transfers.</li> <li>Features: Support for multiple protocols, connection pooling, and secure credential handling.</li> <li>Edge Cases: Network failures, authentication errors, and protocol timeouts.</li> </ul>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#5-logging-and-observability-module","title":"5. Logging and Observability Module","text":"<ul> <li>Functions: Provide structured logging, telemetry, and audit trails.</li> <li>Features: Integration with SIEM/log management tools (Splunk, ELK, etc.), real-time alerts, and compliance reporting.</li> <li>Edge Cases: Log storage limits, sensitive data redaction, and log correlation across devices.</li> </ul>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#6-operator-interaction-module","title":"6. Operator Interaction Module","text":"<ul> <li>Functions: Support CLI-based prompts, approvals, and rollback triggers.</li> <li>Features: Human-in-the-loop workflows, escalation procedures, and notification integration (email, Slack, etc.).</li> <li>Edge Cases: Operator unavailability, approval timeouts, and conflicting actions.</li> </ul>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#7-integration-module","title":"7. Integration Module","text":"<ul> <li>Functions: Interface with external automation tools (Ansible, Netmiko, Nornir, DNA Center).</li> <li>Features: API adapters, event hooks, and data synchronization.</li> <li>Edge Cases: Version mismatches, API changes, and integration failures.</li> </ul>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#fault-tolerance-retries-and-idempotency","title":"Fault Tolerance, Retries, and Idempotency","text":"<p>Fault Tolerance: The orchestrator must gracefully handle transient and permanent failures at every stage. This includes: - Retries: Implement exponential backoff for network or transfer errors. - Dead Letter Queues: Capture and log unrecoverable failures for manual intervention. - Circuit Breakers: Temporarily halt operations on repeated failures to avoid cascading issues. - Observability: Provide real-time metrics and alerts for failures, retries, and workflow status.  </p> <p>Idempotency: All operations should be designed so that repeated execution with the same input yields the same result, preventing unintended side effects (e.g., duplicate image transfers, repeated reloads).</p> <p>Decision Tree Diagram Description: Fault Handling</p> <pre><code>[Start Upgrade]\n      |\n      v\n[Pre-Check Success?]--No--&gt;[Abort/Notify]\n      |\n     Yes\n      v\n[Image Transfer Success?]--No--&gt;[Retry (max N)?]--No--&gt;[Dead Letter/Alert]\n      |                                 |\n     Yes                                Yes\n      v                                  v\n[Upgrade Execution Success?]--No--&gt;[Rollback/Notify]\n      |\n     Yes\n      v\n[Post-Check Success?]--No--&gt;[Rollback/Notify]\n      |\n     Yes\n      v\n[Mark Success/Complete]\n</code></pre>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#edge-case-handling","title":"Edge Case Handling","text":"","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#dual-supervisors-sups-and-stackwise-virtual","title":"Dual Supervisors (SUPs) and StackWise Virtual","text":"<ul> <li>Dual SUPs: Upgrade standby supervisor first, verify, then switchover and upgrade the former active. Ensure SSO is maintained and minimize traffic disruption.</li> <li>StackWise Virtual: Coordinate upgrade across both virtual stack members, ensuring version consistency and stack health.</li> <li>Chassis-Specific Behaviors: Handle platform-specific requirements (e.g., bootloader/CPLD upgrades, module compatibility).</li> </ul> <p>Best Practices</p> <ul> <li>Automate detection of redundancy state and adapt workflow accordingly.</li> <li>Validate both active and standby SUPs post-upgrade.</li> <li>For StackWise, use <code>software auto-upgrade enable</code> to synchronize stack members.</li> </ul> <p>Common Pitfalls</p> <ul> <li>Upgrading both SUPs simultaneously, causing loss of redundancy.</li> <li>Stack member version mismatches leading to split-brain.</li> </ul>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#issu-vs-non-issu-upgrades","title":"ISSU vs. Non-ISSU Upgrades","text":"<p>ISSU (In-Service Software Upgrade): - Supported Platforms: Only certain Catalyst 9k models with dual SUPs/StackWise Virtual, and only within specific release trains. - Benefits: Minimal or no downtime, seamless traffic switchover. - Limitations: Not supported on all platforms or for major version jumps.  </p> <p>Non-ISSU: - Supported Platforms: All. - Drawbacks: Requires device reload, causes downtime.  </p> <p>ISSU Support Matrix Table (Excerpt)</p> Platform ISSU Supported Min. Release Notes Cat 9400 (dual) Yes 16.9.1 SSO required Cat 9500 (SVL) Yes 16.9.2 StackWise Virtual only Cat 9600 (dual) Yes 16.12.1 SSO required ISR/ASR Routers No N/A Only non-ISSU <p>Decision Tree: ISSU vs. Non-ISSU</p> <pre><code>[Is Platform ISSU-Capable?]--No--&gt;[Use Non-ISSU]\n      |\n     Yes\n      v\n[Is Upgrade Within Supported Release Train?]--No--&gt;[Use Non-ISSU]\n      |\n     Yes\n      v\n[ISSU Upgrade]\n</code></pre>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#platform-specific-considerations","title":"Platform-Specific Considerations","text":"<p>Platform Requirements</p> <ul> <li>Catalyst 9k: Prefer Install Mode, support for ISSU in certain scenarios, modular image management.</li> <li>ISR/ASR Routers: Typically non-ISSU, require reload, ensure VM memory for virtual platforms.</li> <li>NCS: May have unique upgrade steps, especially for service provider features.</li> </ul> <p>Always Consult Cisco Documentation</p> <p>Always consult latest Cisco release notes for platform-specific caveats. Maintain a mapping of platform capabilities and required upgrade steps.</p>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#state-management-and-excel-driven-source-of-truth","title":"State Management and Excel-Driven Source-of-Truth","text":"<p>Excel as SoT: Excel (or CSV) files are commonly used as the initial source-of-truth for device inventory and upgrade parameters. For scalability and reliability, consider migration to a database or open-source SoT tool (e.g., NetBox) as the environment grows.</p> <p>Key Data Fields: - Device hostname, management IP, platform/model, current version, target version, image path, upgrade status, last upgrade timestamp, rollback status, operator notes.</p> <p>State Persistence: - Update Excel/SoT after each workflow stage (e.g., pre-check passed, image transferred, upgrade complete). - Use version control (e.g., Git) for change tracking and auditability.</p> <p>Integration Strategies: - Abstract Excel/CSV access behind a data access layer for future migration to databases or APIs. - Support bidirectional updates (orchestration writes status, operators can update approvals/notes).</p>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#cli-based-interaction-model-and-operator-workflows","title":"CLI-Based Interaction Model and Operator Workflows","text":"<p>CLI Interaction: - The orchestrator should support CLI-based prompts for operator approvals, rollback triggers, and status queries. - For human-in-the-loop workflows, implement approval gates before disruptive actions (e.g., reload, rollback).</p> <p>Operator Workflow Example: 1. Operator reviews pre-check results and approves upgrade. 2. Orchestrator proceeds with image transfer and upgrade. 3. If post-checks fail, operator is prompted to approve rollback. 4. All actions and approvals are logged for compliance.</p> <p>Best Practices: - Provide clear, actionable prompts and status messages. - Support both interactive and unattended (batch) modes. - Integrate with notification systems (email, Slack, etc.) for approvals and alerts.</p>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#security-considerations","title":"Security Considerations","text":"<p>Critical Security Requirements</p> <p>Credential Management:</p> <ul> <li>Store device credentials securely (e.g., encrypted vault, environment variables).</li> <li>Support per-device or per-group credentials for least privilege.</li> </ul> <p>Image Integrity:</p> <ul> <li>Always verify image hashes before and after transfer.</li> <li>Use signed images where supported.</li> </ul> <p>Access Controls:</p> <ul> <li>Restrict orchestrator execution to authorized operators.</li> <li>Log all actions for auditability.</li> </ul> <p>Network Security:</p> <ul> <li>Use secure protocols (SSH, SCP, HTTPS) for all device and file transfers.</li> <li>Avoid exposing sensitive data in logs or error messages.</li> </ul>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#logging-telemetry-and-observability","title":"Logging, Telemetry, and Observability","text":"<p>Logging: - Structured, timestamped logs for all workflow stages, actions, and errors. - Integration with log management/SIEM tools for compliance and troubleshooting.</p> <p>Telemetry: - Metrics on upgrade duration, success/failure rates, transfer speeds, and error types. - Real-time dashboards for monitoring upgrade progress across devices.</p> <p>Audit Trails: - Record all operator actions, approvals, and rollbacks. - Retain logs for compliance with regulatory requirements.</p>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#human-in-the-loop-and-approvalrollback-policies","title":"Human-in-the-Loop and Approval/Rollback Policies","text":"<p>Approval Workflows: - Require operator approval before disruptive actions (reload, rollback). - Support fast-track approvals for critical or emergency upgrades.</p> <p>Escalation Procedures: - Define escalation paths for failed upgrades or unresponsive operators. - Integrate with incident management systems (PagerDuty, ServiceNow).</p> <p>Audit Logging: - Maintain detailed records of all approvals, rejections, and escalations.</p>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#testing-staging-and-lab-validation-strategies","title":"Testing, Staging, and Lab Validation Strategies","text":"<p>Staging: - Test orchestrator workflows in a lab environment with representative hardware and topologies. - Simulate common failure scenarios (e.g., image corruption, flash full, network loss).</p> <p>Verification Matrices: - Maintain test matrices covering ISSU vs. non-ISSU, platform types, and edge cases.</p> <p>Best Practices: - Use golden images and known-good configurations for baseline validation. - Automate test execution and result collection.</p>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#common-pitfalls-and-failure-modes","title":"Common Pitfalls and Failure Modes","text":"<p>Critical Pitfalls to Avoid</p> <ul> <li>Skipping image hash verification, leading to boot failures.</li> <li>Insufficient flash space, causing transfer or install failures.</li> <li>Boot variable misconfiguration, resulting in ROMmon boots.</li> <li>Stack member version mismatches, causing split-brain.</li> <li>Incomplete backups, complicating recovery.</li> </ul> <p>Failure Modes</p> <ul> <li>Network loss during transfer or upgrade.</li> <li>Device reloads into ROMmon due to image or config errors.</li> <li>Partial stack upgrades, leaving members out-of-sync.</li> </ul> <p>Mitigation Strategies</p> <ul> <li>Automate all checks and halt on critical failures.</li> <li>Maintain robust rollback and recovery procedures.</li> <li>Log and alert on all failures for rapid response.</li> </ul>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#integration-with-existing-automation-tools","title":"Integration with Existing Automation Tools","text":"","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#why-python-cisco-catalyst-center-dna-center-enhanced-capabilities","title":"Why Python + Cisco Catalyst Center (DNA Center) = Enhanced Capabilities","text":"<p>Couldn't I Just Use Catalyst Center Instead?</p> <p>This is a common and valid question. Cisco Catalyst Center (formerly DNA Center) provides excellent GUI-driven software upgrade capabilities with Software Image Management (SWIM). So why build a Python orchestrator?</p> <p>The answer: Python and Catalyst Center are complementary, not competing solutions. Python orchestration enhances and extends Catalyst Center's capabilities rather than replacing them.</p> <p>Key Limitations of Catalyst Center Alone:</p> <ol> <li> <p>Workflow Customization Constraints</p> <ul> <li>Catalyst Center provides standardized workflows optimized for common use cases, but enterprises often require bespoke logic (e.g., custom pre-checks, integration with legacy ticketing systems, specific maintenance window rules).</li> <li>Python orchestrators enable fully customized workflow stages, conditional logic, and integration points that may not be exposed via the Catalyst Center GUI or standard APIs.</li> </ul> </li> <li> <p>Multi-Vendor and Hybrid Environments</p> <ul> <li>Catalyst Center is Cisco-centric by design. Enterprises with multi-vendor networks (e.g., Cisco + Arista, Juniper, Palo Alto) require orchestration that spans platforms.</li> <li>Python scripts using libraries like Netmiko, Nornir, or NAPALM can manage heterogeneous device estates with unified logic.</li> </ul> </li> <li> <p>Granular Control and Rollback Flexibility</p> <ul> <li>While Catalyst Center supports upgrades and basic rollback, Python orchestrators provide fine-grained control over every command executed, error handling strategies, and multi-tier rollback mechanisms (image + config + validation).</li> <li>Critical for high-stakes environments where \"good enough\" automation isn't acceptable.</li> </ul> </li> <li> <p>Excel/CSV Source-of-Truth Integration</p> <ul> <li>Many enterprises rely on Excel, CSV, or legacy CMDBs as their authoritative inventory. Python orchestrators can directly consume and update these sources.</li> <li>Catalyst Center requires devices to be onboarded and managed within its inventory system, which may not align with existing operational workflows.</li> </ul> </li> <li> <p>Cost and Licensing</p> <ul> <li>Catalyst Center requires licensing and infrastructure (dedicated appliance or VM cluster). For smaller environments or specific use cases, a Python orchestrator offers zero-cost flexibility.</li> <li>Python scripts can be version-controlled in Git, shared across teams, and deployed without additional licensing overhead.</li> </ul> </li> <li> <p>Edge Case and Platform-Specific Handling</p> <ul> <li>Python orchestrators can implement highly specialized logic for edge cases (e.g., StackWise version mismatch recovery, FPGA upgrades on NCS platforms, legacy ISR router nuances) that may not be fully supported by Catalyst Center's standardized workflows.</li> </ul> </li> </ol> <p>How Python Orchestrators Enhance Catalyst Center:</p> <p>Synergistic Integration Strategies</p> <p>1. Use Catalyst Center as the Source-of-Truth</p> <ul> <li>Leverage Catalyst Center's Intent API to query device inventory, software compliance status, and health metrics.</li> <li>Python orchestrators can consume this data via REST APIs, eliminating the need to maintain separate inventory files.</li> <li>Example: <code>GET /dna/intent/api/v1/network-device</code> retrieves device details; Python script uses this to build upgrade candidates list.</li> </ul> <p>2. Trigger Python Workflows from Catalyst Center Events</p> <ul> <li>Use Catalyst Center's Event Management (Eastbound) APIs to trigger Python orchestrators when specific conditions occur (e.g., device out of compliance, critical CVE detected).</li> <li>Python script executes custom pre-checks, stages images, and performs upgrades, then reports status back to Catalyst Center via REST APIs.</li> </ul> <p>3. Hybrid Orchestration: Catalyst Center + Python</p> <ul> <li>Use Catalyst Center for standard, low-risk upgrades (e.g., access switches during maintenance windows).</li> <li>Reserve Python orchestrators for high-stakes, complex scenarios (e.g., core routers, dual-SUP chassis, StackWise Virtual, or devices requiring custom validation logic).</li> </ul> <p>4. Extend Catalyst Center with Custom Integrations</p> <ul> <li>Python scripts can integrate Catalyst Center with third-party tools not natively supported (e.g., ServiceNow, Slack, legacy CMDB systems, custom dashboards).</li> <li>Example: Python orchestrator fetches upgrade candidates from Catalyst Center, cross-references with ServiceNow change tickets, executes upgrades, and updates both systems.</li> </ul> <p>5. Reporting and Analytics</p> <ul> <li>Catalyst Center provides robust reporting, but Python orchestrators can generate bespoke reports tailored to specific compliance, audit, or operational requirements.</li> <li>Example: Export upgrade history to Excel with custom formatting, compare against baseline configurations, and highlight deviations.</li> </ul> <p>Real-World Use Case: Python + Catalyst Center</p> <p>An enterprise network team manages 5,000 Catalyst switches via Catalyst Center. For routine access-layer upgrades, they use Catalyst Center's SWIM workflows (GUI-driven, scheduled during maintenance windows). However, for core distribution layer upgrades involving dual-SUP Catalyst 9600 chassis with StackWise Virtual, they use a Python orchestrator because:</p> <ul> <li>Custom pre-checks validate inter-chassis link health and SSO readiness (logic not exposed via Catalyst Center GUI).</li> <li>Integration with ServiceNow ensures upgrade is approved and scheduled in a formal change window.</li> <li>Bespoke rollback logic verifies both active and standby SUPs post-upgrade and triggers automatic rollback if inter-chassis communication fails.</li> <li>Python orchestrator updates Catalyst Center inventory via REST API post-upgrade, ensuring single source-of-truth consistency.</li> </ul> <p>Decision Matrix: When to Use What</p> Scenario Catalyst Center Alone Python Orchestrator Alone Python + Catalyst Center Standard access switch upgrades \u2705 Recommended \u274c Overkill \u2705 Optional (for audit) Dual-SUP core upgrades \u26a0\ufe0f Limited control \u2705 Recommended \u2705 Best of both worlds Multi-vendor environment \u274c Cisco-only \u2705 Required \u2705 Leverage for Cisco devices Excel-driven inventory \u274c Not supported \u2705 Native support \u26a0\ufe0f Requires sync logic Integration with legacy ITSM \u26a0\ufe0f Limited options \u2705 Fully customizable \u2705 Optimal integration Zero licensing cost \u274c Requires license \u2705 Open-source \u2705 Hybrid approach <p>Best Practice Recommendation</p> <p>Use Catalyst Center as your centralized management platform for routine operations, and develop Python orchestrators for specialized workflows, edge cases, and integrations that extend Catalyst Center's capabilities. This hybrid approach maximizes automation ROI while maintaining flexibility and control.</p>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#why-python-ansible-powerful-hybrid-orchestration","title":"Why Python + Ansible = Powerful Hybrid Orchestration","text":"<p>Couldn't I Just Use Ansible Instead?</p> <p>Another excellent question. Ansible is the industry-standard automation platform with excellent Cisco network module support (<code>cisco.ios</code>, <code>ansible.netcommon</code>). Many teams already use Ansible for configuration management, so why build a Python orchestrator?</p> <p>The answer: Ansible and Python are complementary tools that serve different orchestration paradigms. Each has unique strengths, and combining them creates a more robust automation ecosystem.</p> <p>Key Differences: Ansible vs. Python Orchestration</p> <ol> <li> <p>Declarative vs. Imperative Paradigm</p> <ul> <li>Ansible: Declarative approach\u2014you describe the desired end state, and Ansible figures out how to achieve it. Excellent for idempotent configuration management.</li> <li>Python: Imperative approach\u2014you explicitly define each step, decision point, and error-handling path. Essential for complex, stateful workflows with conditional logic.</li> <li>Why It Matters: IOS-XE upgrades require procedural orchestration (pre-check \u2192 transfer \u2192 activate \u2192 verify \u2192 rollback if needed). While Ansible can execute these steps, Python provides finer control over workflow state, retry logic, and multi-stage rollback.</li> </ul> </li> <li> <p>State Management and Workflow Complexity</p> <ul> <li>Ansible: Task-based execution with limited native support for complex workflow state (e.g., tracking upgrade phases, partial failures, resumption after interruption).</li> <li>Python: Full programming language capabilities\u2014maintain upgrade state in Excel/DB, implement circuit breakers, dead letter queues, and sophisticated retry logic with exponential backoff.</li> <li>Why It Matters: For enterprise-scale upgrades affecting hundreds of devices, you need robust state persistence, failure tracking, and the ability to resume workflows after operator intervention or transient failures.</li> </ul> </li> <li> <p>Dynamic Decision Trees and Conditional Logic</p> <ul> <li>Ansible: Supports conditionals (<code>when:</code>) and loops, but complex decision trees become verbose and harder to maintain.</li> <li>Python: Native support for intricate conditional logic, nested decision trees (e.g., ISSU vs. non-ISSU determination based on platform, version, redundancy state), and real-time operator approvals.</li> <li>Why It Matters: IOS-XE upgrades involve platform-specific nuances (Install vs. Bundle mode, StackWise handling, dual-SUP coordination) that require deep conditional logic.</li> </ul> </li> <li> <p>Integration with Excel, CSV, and Legacy Systems</p> <ul> <li>Ansible: Can consume YAML/JSON inventories, but native Excel/CSV manipulation is limited. Requires external modules or pre-processing scripts.</li> <li>Python: Libraries like <code>openpyxl</code>, <code>pandas</code>, and <code>xlsxwriter</code> provide native Excel read/write capabilities, essential for enterprises using spreadsheets as source-of-truth.</li> <li>Why It Matters: Many network teams maintain device inventories, upgrade schedules, and compliance matrices in Excel. Python orchestrators can directly read, update, and generate professional Excel reports with conditional formatting.</li> </ul> </li> <li> <p>Real-Time Operator Interaction and Approvals</p> <ul> <li>Ansible: Primarily designed for unattended execution. Human-in-the-loop workflows require external orchestration (e.g., AWX/Tower with manual approval steps).</li> <li>Python: Native support for CLI-based prompts, approval gates, and rollback triggers. Operators can intervene at any workflow stage.</li> <li>Why It Matters: High-stakes core router upgrades often require operator approval before executing reload commands or initiating rollback.</li> </ul> </li> <li> <p>Error Handling Granularity</p> <ul> <li>Ansible: Built-in error handling via <code>block/rescue/always</code>, but granular control over specific error types, retry strategies, and escalation paths can be challenging.</li> <li>Python: Full exception handling with try/except blocks, custom error classes, and fine-grained retry logic (e.g., retry SSH failures 3 times, but abort immediately on authentication errors).</li> <li>Why It Matters: Network automation requires nuanced error handling\u2014transient network blips should retry, but critical failures (corrupt image, boot variable misconfiguration) should halt and alert.</li> </ul> </li> </ol> <p>How Python Orchestrators Enhance Ansible:</p> <p>Synergistic Integration Strategies</p> <p>1. Use Python as the Workflow Orchestrator, Ansible as the Execution Engine</p> <ul> <li>Python script manages upgrade workflow state (discovery \u2192 pre-check \u2192 transfer \u2192 upgrade \u2192 verify \u2192 rollback).</li> <li>At each stage, Python calls Ansible playbooks via <code>ansible-runner</code> Python library to execute device-level tasks.</li> <li>Example: Python orchestrator determines which devices need upgrades, calls Ansible playbook to transfer images in parallel, tracks success/failure, and proceeds to next stage only when all transfers complete.</li> </ul> <p>2. Leverage Ansible for Device-Level Idempotency, Python for Workflow Logic</p> <ul> <li>Use Ansible modules for idempotent operations (e.g., <code>cisco.ios.ios_command</code> ensures commands execute correctly, <code>ansible.netcommon.net_get</code> handles file transfers).</li> <li>Python orchestrator handles non-idempotent workflow decisions (e.g., \"If pre-check fails, abort upgrade and notify operator\").</li> </ul> <p>3. Python Orchestrator Generates Dynamic Ansible Inventories</p> <ul> <li>Python reads device list from Excel, applies business logic (e.g., filter by maintenance window, exclude devices with active incidents), and generates Ansible inventory files.</li> <li>Ansible playbooks consume dynamically generated inventories, ensuring only eligible devices are targeted.</li> </ul> <p>4. Use Ansible for Multi-Vendor Normalization, Python for Cisco-Specific Logic</p> <ul> <li>Ansible's multi-vendor module support (IOS, NX-OS, Junos, Arista) handles cross-platform command execution.</li> <li>Python orchestrator implements Cisco IOS-XE-specific upgrade logic (Install Mode, ISSU detection, StackWise coordination) not covered by generic Ansible modules.</li> </ul> <p>5. Ansible Playbooks as Reusable Components in Python Workflows</p> <ul> <li>Develop modular Ansible playbooks for reusable tasks (backup configs, verify image hash, check flash space).</li> <li>Python orchestrator calls these playbooks as needed, combining them into bespoke upgrade workflows tailored to specific device groups or scenarios.</li> </ul> <p>Real-World Use Case: Python + Ansible</p> <p>A network team manages upgrades for 3,000 Cisco devices (mix of IOS, IOS-XE, NX-OS). They use:</p> <ul> <li>Ansible playbooks for standard, repeatable tasks: configuration backups, image transfers, and post-upgrade verification commands (leveraging existing Ansible roles and modules).</li> <li>Python orchestrator for workflow management: reading upgrade schedules from Excel, determining upgrade eligibility (cross-referencing ServiceNow change tickets), coordinating upgrade stages, tracking state in Excel, and handling complex rollback logic.</li> <li>Integration: Python script calls Ansible playbooks via <code>subprocess</code> or <code>ansible-runner</code>, passing dynamic inventories and extra variables (e.g., target IOS-XE version, image path).</li> </ul> <p>Benefits: - Reuses existing Ansible playbooks developed by the team (no reinventing the wheel). - Python orchestrator adds enterprise-specific workflow logic (Excel integration, approval gates, advanced error handling) not feasible in pure Ansible. - Operators familiar with Ansible can still contribute playbooks, while Python developers enhance orchestration layer.</p> <p>Decision Matrix: When to Use What</p> Scenario Ansible Alone Python Orchestrator Alone Python + Ansible Simple config changes \u2705 Recommended \u274c Overkill \u274c Overkill Multi-stage upgrade workflows \u26a0\ufe0f Complex playbooks \u2705 Recommended \u2705 Best of both worlds Excel-driven inventory \u26a0\ufe0f Requires pre-processing \u2705 Native support \u2705 Python reads, Ansible executes Multi-vendor environments \u2705 Excellent support \u26a0\ufe0f Custom per-vendor logic \u2705 Ansible modules + Python orchestration Real-time operator approvals \u26a0\ufe0f Requires AWX/Tower \u2705 Native CLI prompts \u2705 Python prompts + Ansible tasks Team already uses Ansible \u2705 Leverage existing investment \u26a0\ufe0f Learning curve \u2705 Extend Ansible with Python Complex rollback logic \u26a0\ufe0f Limited state tracking \u2705 Full control \u2705 Python logic + Ansible execution <p>Best Practice Recommendation</p> <p>Use Ansible for device-level task execution and idempotency, and develop Python orchestrators for workflow state management, conditional logic, and integrations that extend Ansible's capabilities. This approach leverages Ansible's mature ecosystem while adding the flexibility and control of Python for complex enterprise workflows.</p>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#nornir-the-python-native-framework-for-scalable-network-automation","title":"Nornir: The Python-Native Framework for Scalable Network Automation","text":"<p>What is Nornir?</p> <p>Nornir is a pure-Python automation framework specifically designed for network operations at scale. Unlike Ansible (which uses YAML-based playbooks), Nornir is Python-native\u2014you write automation logic in Python itself, giving you the full power of a programming language without abstraction layers.</p> <p>Why it's less known: Nornir is newer (first released in 2018) and targets a more technical audience (network engineers who code in Python). It lacks the marketing presence of Ansible/Red Hat, but has become the framework of choice for sophisticated network automation engineers who need Python's flexibility with built-in scalability.</p> <p>Why Nornir is Ideally Suited for IOS-XE Upgrade Orchestration:</p> <ol> <li> <p>Python-Native Design</p> <ul> <li>No DSL Abstraction: You write pure Python\u2014no need to learn YAML syntax, Jinja2 templating quirks, or Ansible-specific modules. If you know Python, you know Nornir.</li> <li>Full Language Features: Use classes, decorators, context managers, async/await, and any Python library (openpyxl, pandas, requests) directly in your automation logic.</li> <li>Why It Matters: IOS-XE upgrades require complex conditional logic, state management, and error handling that's easier to express in Python than YAML-based playbooks.</li> </ul> </li> <li> <p>Built-In Parallelization and Thread Management</p> <ul> <li>Automatic Concurrency: Nornir executes tasks across devices in parallel using thread pools (configurable workers). No need to manually manage threading like you would with raw Netmiko + threading.</li> <li>Granular Control: Set concurrency limits per task (e.g., 50 concurrent connections for pre-checks, but only 10 for image transfers to avoid network saturation).</li> <li>Why It Matters: Upgrading hundreds of devices requires efficient parallelization. Nornir handles this out-of-the-box with better control than Ansible's <code>serial</code> or <code>forks</code> settings.</li> </ul> </li> <li> <p>Flexible Inventory System</p> <ul> <li>Multiple Inventory Sources: Nornir supports SimpleInventory (YAML), NetBox, Ansible inventory, or custom inventory plugins. You can also build inventories programmatically from Excel, CSV, or databases.</li> <li>Rich Host Data: Each host object carries arbitrary data (groups, custom attributes, credentials), accessible in tasks.</li> <li>Why It Matters: For Excel-driven workflows, you can write a custom Nornir inventory plugin that reads directly from Excel, mapping columns to host attributes (platform, target version, maintenance window).</li> </ul> </li> <li> <p>Plugin Architecture for Extensibility</p> <ul> <li>Task Plugins: Encapsulate reusable operations (e.g., <code>netmiko_send_command</code>, <code>napalm_get</code>, custom <code>ios_xe_upgrade_install_mode</code>).</li> <li>Connection Plugins: Manage device connections (Netmiko, NAPALM, Scrapli, or custom SSH implementations).</li> <li>Inventory, Processor, and Runner Plugins: Customize every aspect of Nornir's behavior.</li> <li>Why It Matters: You can develop custom plugins for IOS-XE-specific upgrade operations (StackWise coordination, dual-SUP handling) and reuse them across projects.</li> </ul> </li> <li> <p>Integrated Result Object and Error Handling</p> <ul> <li>Structured Results: Every task returns a <code>Result</code> object with success/failure status, output, exception details, and host info. Results are aggregated in a <code>AggregatedResult</code> object for easy analysis.</li> <li>Granular Error Handling: Continue executing tasks even if some hosts fail (<code>on_failed=True</code>), or halt execution on first failure. Analyze failed hosts and retry selectively.</li> <li>Why It Matters: Upgrades involve multi-stage workflows where you need to track which devices succeeded/failed at each stage (pre-check, transfer, upgrade, verify) and handle partial failures gracefully.</li> </ul> </li> <li> <p>Integration with Netmiko, NAPALM, and Scrapli</p> <ul> <li>Leverage Existing Libraries: Nornir plugins provide seamless integration with Netmiko (CLI automation), NAPALM (structured data retrieval), and Scrapli (fast, modern SSH library).</li> <li>Best of Both Worlds: Use Netmiko for raw CLI commands, NAPALM for standardized getters (facts, interfaces), and Scrapli for performance-critical operations.</li> <li>Why It Matters: You don't reinvent the wheel\u2014Nornir orchestrates existing, battle-tested libraries while providing structure, parallelization, and result handling.</li> </ul> </li> </ol> <p>How Nornir Enhances This Python Orchestrator:</p> <p>Integration Strategies</p> <p>1. Use Nornir as the Core Execution Engine</p> <ul> <li>Replace custom threading/multiprocessing code with Nornir's built-in parallelization.</li> <li>Define upgrade workflow stages as Nornir tasks: <code>pre_check_task()</code>, <code>transfer_image_task()</code>, <code>upgrade_task()</code>, <code>verify_task()</code>.</li> <li>Execute tasks across device inventory with automatic concurrency management: <code>nr.run(task=pre_check_task)</code>.</li> </ul> <p>2. Custom Nornir Inventory from Excel</p> <ul> <li>Develop a custom Nornir inventory plugin that reads device list, credentials, and upgrade parameters from Excel.</li> <li>Map Excel columns to Nornir host attributes: <code>hostname</code>, <code>platform</code>, <code>target_version</code>, <code>maintenance_window</code>, etc.</li> <li>Filter inventory dynamically: <code>nr_filtered = nr.filter(platform=\"catalyst9k\", maintenance_window=\"tonight\")</code>.</li> </ul> <p>3. Encapsulate IOS-XE Upgrade Logic in Nornir Tasks</p> <ul> <li>Create custom Nornir tasks for platform-specific operations:<ul> <li><code>ios_xe_install_mode_upgrade()</code>: Handles <code>install add</code>, <code>install activate</code>, <code>install commit</code> workflow.</li> <li><code>stackwise_version_check()</code>: Validates all stack members are running same version.</li> <li><code>dual_sup_upgrade()</code>: Coordinates standby-first upgrade logic.</li> </ul> </li> <li>Reuse tasks across different upgrade scenarios and device groups.</li> </ul> <p>4. Leverage Nornir Processors for Logging and State Tracking</p> <ul> <li>Use Nornir's <code>processor</code> framework to automatically log every task execution to Excel, database, or SIEM.</li> <li>Example: Custom processor updates Excel row with upgrade status after each task completes.</li> </ul> <p>5. Conditional Task Execution Based on Results</p> <ul> <li>Analyze <code>AggregatedResult</code> after each stage to determine next steps:     <pre><code>result = nr.run(task=pre_check_task)\nfailed_hosts = [host for host, r in result.items() if r.failed]\nif failed_hosts:\n    # Remove failed hosts from inventory, notify operator\n    nr = nr.filter(~F(name__any=failed_hosts))\nnr.run(task=transfer_image_task)  # Only successful hosts proceed\n</code></pre></li> <li>Implement multi-tier rollback: if post-verification fails, execute rollback tasks only on affected hosts.</li> </ul> <p>Nornir vs. Raw Python with Netmiko/Threading:</p> Aspect Raw Python + Netmiko + Threading Nornir + Netmiko Parallelization Manual thread pool management Built-in, configurable workers Inventory Management Custom data structures (lists, dicts) Rich inventory objects with filtering Task Encapsulation Functions scattered across modules Reusable task plugins Result Handling Manual result aggregation Structured <code>Result</code> and <code>AggregatedResult</code> Error Handling Try/except in each thread Integrated failure tracking Code Complexity Higher (threading boilerplate) Lower (framework handles concurrency) Reusability Limited (project-specific) High (plugins, tasks shareable) Learning Curve Python threading/multiprocessing Nornir concepts (tasks, inventory, results) <p>Real-World Use Case: Nornir-Powered Upgrade Orchestrator</p> <p>A network team develops an IOS-XE upgrade orchestrator using Nornir:</p> <ol> <li>Custom Excel Inventory Plugin: Reads device list from Excel (hostname, IP, platform, target version, maintenance window). Filters devices scheduled for tonight's maintenance window.</li> <li>Pre-Check Task: Nornir executes <code>pre_check_task()</code> across 200 devices in parallel (20 workers). Task uses Netmiko to check flash space, version, and redundancy status. Results aggregated; 5 devices fail (insufficient flash). Excel updated with failure reasons.</li> <li>Image Transfer Task: Remaining 195 devices proceed to <code>transfer_image_task()</code>. Task uses SCP via Netmiko, verifies hash. 2 devices fail (network timeout). Orchestrator logs failures, removes from inventory.</li> <li>Upgrade Task: 193 devices execute <code>ios_xe_install_mode_upgrade()</code> task. Task detects dual-SUP chassis, executes standby-first upgrade logic. Real-time progress logged to Excel.</li> <li>Verification Task: <code>verify_task()</code> confirms version, redundancy, and interface status. All devices pass.</li> <li>Rollback Logic: If any device failed verification, orchestrator would execute <code>rollback_task()</code> only on failed hosts.</li> </ol> <p>Benefits: - Minimal Boilerplate: Nornir handles threading, connection pooling, result aggregation\u2014team focuses on upgrade logic. - Parallel Execution: 200 devices pre-checked in minutes (vs. hours sequentially). - Structured Results: Easy to identify which devices failed at which stage, generate Excel reports. - Reusable Tasks: <code>dual_sup_upgrade()</code> task reused across multiple projects.</p> <p>Decision Matrix: When to Use Nornir</p> Scenario Raw Python + Netmiko Nornir + Netmiko Ansible Small-scale (&lt; 10 devices) \u2705 Simple, sufficient \u26a0\ufe0f Overkill \u2705 Quick playbooks Large-scale (100+ devices) \u26a0\ufe0f Manual threading overhead \u2705 Ideal choice \u2705 Good option Complex Python logic \u2705 Full control \u2705 Best of both worlds \u26a0\ufe0f YAML limitations Team already uses Ansible \u26a0\ufe0f Learning curve \u26a0\ufe0f Paradigm shift \u2705 Leverage existing Need reusable task library \u26a0\ufe0f Manual abstraction \u2705 Plugin architecture \u26a0\ufe0f Role-based reuse Excel-driven workflows \u2705 Full flexibility \u2705 Custom inventory plugin \u26a0\ufe0f Requires pre-processing Real-time operator interaction \u2705 Native Python \u2705 Native Python \u26a0\ufe0f Requires AWX/Tower <p>Best Practice Recommendation</p> <p>For Python-first teams building large-scale network automation, Nornir is the ideal framework. It provides structure, scalability, and built-in parallelization without sacrificing Python's flexibility. For this IOS-XE upgrade orchestrator, Nornir would serve as the execution engine, handling device connections, task parallelization, and result aggregation, while your custom Python logic manages workflow orchestration, Excel integration, and business rules.</p>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#other-automation-tool-integrations","title":"Other Automation Tool Integrations","text":"<p>Netmiko (Standalone): For teams not using Nornir or Ansible, integrate Netmiko directly for low-level device connection management and command execution. Requires manual thread management for parallel operations.</p> <p>Source-of-Truth Tools: Plan for future migration from Excel to NetBox, Git, or other SoT platforms for improved scalability and reliability. Both Nornir and Ansible provide native NetBox inventory plugins.</p>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#compliance-audit-trail-and-reporting","title":"Compliance, Audit Trail, and Reporting","text":"<p>Compliance: - Ensure all upgrade actions are logged and traceable. - Generate reports on upgrade status, failures, and operator actions.</p> <p>Audit Trail: - Maintain detailed logs for all workflow stages, approvals, and rollbacks. - Support export to CSV, PDF, or integration with compliance tools.</p> <p>Reporting: - Real-time dashboards for upgrade progress. - Historical reports for trend analysis and continuous improvement.</p>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#error-handling-and-escalation-procedures","title":"Error Handling and Escalation Procedures","text":"<p>Error Handling: - Classify errors (transient vs. permanent) and handle accordingly. - Implement retries with exponential backoff for transient errors. - Route unrecoverable errors to dead letter queues for manual intervention.</p> <p>Escalation: - Notify operators and escalate to higher-level support if errors persist. - Provide actionable error messages and remediation steps.</p>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#smu-fpga-and-platform-firmware-handling","title":"SMU, FPGA, and Platform Firmware Handling","text":"<p>SMU (Software Maintenance Upgrade): - Support installation, activation, and rollback of SMU packages for critical patches. - Automate compatibility checks and ensure SMUs are committed post-activation.</p> <p>FPGA/Firmware: - Detect and manage required FPGA or platform firmware upgrades as part of the workflow. - Schedule firmware upgrades during maintenance windows due to potential reloads.</p>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#time-windows-scheduling-and-maintenance-window-management","title":"Time Windows, Scheduling, and Maintenance Window Management","text":"<p>Scheduling: - Support scheduling upgrades within approved maintenance windows. - Batch upgrades to avoid network congestion and minimize impact.</p> <p>Window Management: - Validate that upgrades do not exceed allocated windows. - Provide rollback triggers if upgrades overrun or fail within the window.</p>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#decision-trees-and-diagrams","title":"Decision Trees and Diagrams","text":"<p>Upgrade Path Decision Tree (Textual Description):</p> <pre><code>[Start]\n  |\n  v\n[Is Device in Install Mode?]--No--&gt;[Convert to Install Mode]\n  |\n Yes\n  v\n[Is Platform ISSU-Capable?]--No--&gt;[Plan Non-ISSU Upgrade]\n  |\n Yes\n  v\n[Is Upgrade Within Supported Release Train?]--No--&gt;[Plan Non-ISSU Upgrade]\n  |\n Yes\n  v\n[Plan ISSU Upgrade]\n</code></pre> <p>Rollback Decision Tree:</p> <pre><code>[Post-Upgrade Health Check]\n  |\n  v\n[Success?]--Yes--&gt;[Mark Complete]\n  |\n No\n  v\n[Is Rollback Possible?]--No--&gt;[Escalate/Manual Intervention]\n  |\n Yes\n  v\n[Initiate Rollback]\n</code></pre>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"coming-soon/IOS-XE%20Software%20Upgrade%20Orchestrator/#conclusion-and-next-steps","title":"Conclusion and Next Steps","text":"<p>A well-designed IOS-XE Software Upgrade Orchestrator is a force multiplier for network operations, enabling safe, scalable, and auditable upgrades across diverse Cisco platforms. By adhering to modular design, best practices, and robust error handling, the orchestrator minimizes risk, reduces downtime, and streamlines compliance. Integration with an Excel-driven source-of-truth and CLI-based operator workflows ensures accessibility and adaptability for a wide range of environments.</p> <p>Next Steps</p> <ul> <li>Finalize module interfaces and data models.</li> <li>Develop and test each module independently, starting with inventory and device abstraction.</li> <li>Implement robust logging, error handling, and rollback mechanisms.</li> <li>Validate workflows in a lab environment, covering all supported platforms and edge cases.</li> <li>Plan for future integration with advanced SoT tools and automation frameworks.</li> </ul> <p>Want to Contribute or Collaborate?</p> <p>This design document is part of Nautomation Prime's commitment to transparent, production-ready automation. If you have feedback, suggestions, or would like to collaborate on implementation, please visit our about page for contact information.</p>","tags":["Coming Soon","IOS-XE","Automation","Software Upgrade","Python","Orchestration"]},{"location":"deep-dives/","title":"Technical Deep Dives","text":"","tags":["Deep Dives","Technical Guides","Education","Python","Enterprise"]},{"location":"deep-dives/#engineering-transparency-into-every-line-of-code","title":"\"Engineering Transparency into Every Line of Code.\"","text":"<p>Welcome to the Nautomation Prime Technical Library. These are not just scripts; they are educational blueprints designed to bridge the gap between complex Cisco infrastructure and hardened Python automation. </p> <p>Our Deep Dives are built for engineers who refuse to treat automation as a \"black box.\" Each guide provides a comprehensive, line-by-line breakdown of production-ready logic, focusing on security, scalability, and error handling.</p>","tags":["Deep Dives","Technical Guides","Education","Python","Enterprise"]},{"location":"deep-dives/#available-deep-dives","title":"\ud83d\udd0d Available Deep Dives","text":"Resource Description Focus Areas CDP Network Audit A threaded discovery utility that crawls Cisco networks via CDP with two-tier authentication and jump server support. Thread-Safety, Two-Tier Auth, Jump-Hosts, DNS Enrichment, TextFSM Access Switch Port Audit Parallel port health collection across your access layer, exported to Excel. Multi-threaded Collection, Stale Detection, PoE Intelligence Upcoming: IOS-XE Software Upgrade Orchestrator Automated, intelligent firmware management for Cisco IOS-XE switch stacks that eliminates manual upgrade errors through comprehensive validation. Pre-Flight Validation, Binary Verification, Stack-Aware Orchestration, Rollback Capability Upcoming: Zero Touch Provisioning (ZTP) Automated deployment solution for Cisco devices that streamlines initial configuration and reduces deployment time. Template-Based Config, DHCP Integration, Remote Logging","tags":["Deep Dives","Technical Guides","Education","Python","Enterprise"]},{"location":"deep-dives/#the-prime-philosophy","title":"\ud83d\udee0\ufe0f The \"Prime\" Philosophy","text":"<p>Every technical guide in this library adheres to three core principles:</p> <ol> <li>Line-by-Line Transparency: We explain the why behind the code, not just the what. If we use a specific library or logic gate, we document the engineering decision behind it.</li> <li>Hardened for Production: Our scripts include robust error handling, credential management, and \"pre-flight\" safety checks to protect your production environment.</li> <li>Vendor-Neutral Foundations: We leverage industry-standard libraries like Netmiko, Nornir, and TextFSM to ensure your skills and scripts remain portable.</li> </ol>","tags":["Deep Dives","Technical Guides","Education","Python","Enterprise"]},{"location":"deep-dives/#how-to-use-these-guides","title":"\ud83d\ude80 How to Use These Guides","text":"<p>Important: These Deep Dives assume you already know Python. We teach you how Python solves network automation problems\u2014not Python fundamentals. If you're new to Python, start with a Python course first, then come back here.</p> <p>Each Deep Dive is structured as:</p> <ul> <li>The Why \u2014 Design decisions and architectural choices</li> <li>The How \u2014 Line-by-line walkthroughs of critical functions</li> <li>The What \u2014 Design patterns and security considerations</li> </ul> <p>Read these alongside the raw source code on GitHub. Whether deploying bespoke solutions or understanding Python at scale with Cisco hardware, start here.</p> <p>Mission: To empower engineers through Python-driven transparency and provide enterprises with hardened automation that eliminates error and accelerates growth.</p>","tags":["Deep Dives","Technical Guides","Education","Python","Enterprise"]},{"location":"deep-dives/access-switch-audit/","title":"Deep Dive: Access Switch Port Audit Tool","text":"","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#enterprise-port-intelligence-distilled-to-pure-python","title":"\"Enterprise Port Intelligence, Distilled to Pure Python.\"","text":"<p>A modular Python utility that connects to Cisco switches (optionally through an SSH jump host), collects comprehensive interface details, PoE information, and neighbor presence, then exports a professional, filters-only Excel workbook with a SUMMARY sheet and one sheet per device. Built for production reliability with YAML-based configuration, intelligent fallback parsing, and customizable credential management.</p> <p> View Source Code on GitHub</p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#what-this-tool-does","title":"\u2728 What This Tool Does","text":"<ul> <li>Audits access ports across multiple Cisco switches in parallel</li> <li>Normalises interface names (e.g., <code>GigabitEthernet1/0/1</code> \u2192 <code>Gi1/0/1</code>) for cross-command matching</li> <li>Enriches interfaces with:</li> <li>PoE draw and state (<code>show power inline</code>)</li> <li>LLDP/CDP neighbour presence (<code>show lldp neighbors detail</code>, <code>show cdp neighbors detail</code>)</li> <li>Classifies port mode &amp; VLAN using <code>show interfaces status</code> (access / trunk / routed)</li> <li>Flags stale access ports using conservative rules</li> <li>Exports Excel with an at-a-glance SUMMARY and one sheet per device, with filters, frozen header, column auto-size, and conditional formatting</li> <li>Shows a progress bar whilst running concurrent device jobs</li> </ul> <p>Design note: The workbook intentionally uses filters only (no Excel tables), and places SUMMARY first.</p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#the-nautomation-prime-philosophy-in-action","title":"\ud83c\udfaf The Nautomation Prime Philosophy in Action","text":"<p>Before diving into the code, understand how every design decision reflects our three core principles:</p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#principle-1-line-by-line-transparency","title":"Principle 1: Line-by-Line Transparency","text":"<p>Every function in this tool includes explicit documentation of what it does and why it's structured this way. You'll see comments explaining the engineering tradeoffs\u2014why we parse with TextFSM and maintain a fallback parser, why we use conservative stale-detection logic, and why conditional formatting in Excel matters for operations teams.</p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#principle-2-hardened-for-production","title":"Principle 2: Hardened for Production","text":"<p>Access layer audits run on infrastructure that cannot afford downtime. You'll notice patterns like concurrent connection pooling, per-device failure isolation, graceful fallbacks when commands fail, and secure credential rotation. These aren't \"nice to have\"\u2014they're mandatory for enterprise reliability.</p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#principle-3-vendor-neutral","title":"Principle 3: Vendor-Neutral","text":"<p>This tool is built on industry-standard Python libraries: Netmiko (multi-device SSH), Paramiko (jump host tunnelling), Pandas &amp; OpenPyXL (Excel generation), and TextFSM (intelligent parsing). Your skills remain portable across vendors.</p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#project-layout","title":"\ud83e\uddf1 Project Layout","text":"<pre><code>.\n\u251c\u2500\u2500 main.py                 # CLI entry point\n\u251c\u2500\u2500 devices.txt             # Example device list\n\u251c\u2500\u2500 config.yaml             # YAML configuration file (NEW!)\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 Modules/\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 config_loader.py    # YAML config parser with type-safe properties\n    \u251c\u2500\u2500 credentials.py      # Secure credential retrieval + fallbacks\n    \u251c\u2500\u2500 jump_manager.py     # SSH jump host (bastion) support\n    \u2514\u2500\u2500 netmiko_utils.py    # Netmiko connection wrapper(s)\n</code></pre> <p>Note: The <code>Modules/*.py</code> files encapsulate most environment-specific behaviour. The new <code>config_loader.py</code> provides a clean interface to YAML-based configuration with validation and type safety.</p> <p>Key Improvement: Configuration is now in human-readable YAML format instead of Python code, making it safer and more accessible to non-developers.</p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#requirements","title":"\ud83d\udce6 Requirements","text":"<ul> <li>Python: 3.8+</li> <li>Python packages:</li> <li><code>netmiko</code></li> <li><code>paramiko</code></li> <li><code>pandas</code></li> <li><code>openpyxl</code></li> <li><code>pywin32</code> (Windows only; used for Windows Credential Manager integration)</li> </ul> <p>Install with pip: <pre><code>pip install netmiko paramiko pandas openpyxl pywin32\n</code></pre></p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#optional-but-recommended","title":"Optional but Recommended","text":"<ul> <li>TextFSM templates (NTC templates) for robust parsing of <code>show interfaces</code> when <code>use_textfsm=True</code>.</li> <li>If templates are available and the <code>NET_TEXTFSM</code> environment variable points to them, parsing accuracy improves.</li> <li>If not available, the script still works and falls back where needed (e.g., it has its own fixed-width parser for <code>show interfaces status</code>).</li> </ul>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#configuration-system","title":"\u2699\ufe0f Configuration System","text":"<p>The tool uses a modern YAML-based configuration system introduced in recent updates.</p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#yaml-configuration-file-configyaml","title":"YAML Configuration File (config.yaml)","text":"<p>All configurable settings are centralized in <code>config.yaml</code> at the project root. The configuration is loaded via <code>Modules/config_loader.py</code> which provides type-safe property accessors.</p> <p>Key Configuration Categories:</p> <p>1. Network Settings: <pre><code>network:\n  jump_host: \"jump-gateway.example.com\"  # Default bastion/jump host\n  device_type: \"cisco_ios\"                # Netmiko device type\n  ssh_port: 22                            # SSH port\n  read_timeout: 30                        # Command read timeout\n</code></pre></p> <p>2. Credential Settings: <pre><code>credentials:\n  cred_target: \"MyApp/ADM\"  # Windows Credential Manager target\n  enable_target: \"\"          # Optional enable secret target\n</code></pre></p> <p>3. Performance &amp; Concurrency: <pre><code>concurrency:\n  default_workers: 10        # Max concurrent device sessions\n  retry_attempts: 3          # Connection retry count\n  retry_base_wait: 2         # Base wait time for exponential backoff\n</code></pre></p> <p>4. Excel Output: <pre><code>output:\n  default_filename: \"audit.xlsx\"  # Default output filename\n\nexcel_formatting:\n  min_column_width: 10\n  max_column_width: 50\n</code></pre></p> <p>5. Stale Port Detection: <pre><code>stale_detection:\n  default_stale_days: 30  # Days threshold for stale ports\n</code></pre></p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#why-yaml-configuration","title":"Why YAML Configuration?","text":"Benefit Explanation Human-Readable No Python knowledge required to modify settings Version Control Friendly Plain text format works seamlessly with Git Safer No code execution risk (pure data) Validated Config loader validates types and provides defaults Hierarchical Natural grouping of related settings Documented Inline comments explain each setting","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#environment-variable-overrides","title":"Environment Variable Overrides","text":"<p>Specific settings can be overridden at runtime via environment variables (primarily for the jump host):</p> <pre><code># Override jump host at runtime\n$env:JUMP_HOST = \"temp-bastion.example.com\"\n</code></pre> <p>Best Practice: Use <code>config.yaml</code> for organizational defaults; use CLI arguments (<code>--direct</code>, <code>--workers</code>, etc.) for per-run overrides.</p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#quick-start-using-the-launcher-recommended","title":"\ud83d\ude80 Quick Start: Using the Launcher (Recommended)","text":"<p>The repository now includes a professional Windows batch launcher (<code>run.bat</code>) that provides the easiest way to run the tool with default settings.</p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#why-use-the-launcher","title":"Why Use the Launcher?","text":"<ul> <li>Zero configuration required - Just double-click or run from command line</li> <li>Automatic validation - Checks for Python environment and required files before execution</li> <li>Helpful diagnostics - Clear error messages if something is missing</li> <li>Professional interface - Clean output with status indicators and progress messages</li> <li>Safe execution - Validates environment before running the script</li> </ul>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#using-runbat","title":"Using run.bat","text":"<p>Option 1: Double-click</p> <p>Simply double-click <code>run.bat</code> in Windows Explorer to launch the tool with default behavior.</p> <p>Option 2: Command Line (Default Behavior)</p> <pre><code>run.bat\n</code></pre> <p>This runs the Access Switch Audit with all default settings from <code>config.yaml</code>.</p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#what-the-launcher-does","title":"What the Launcher Does","text":"<ol> <li>Validates the environment:</li> <li>Checks that the <code>portable_env</code> virtual environment exists</li> <li>Verifies Python executable is present</li> <li>Confirms <code>main.py</code> exists</li> <li> <p>Validates <code>config.yaml</code> and <code>devices.txt</code> are present</p> </li> <li> <p>Provides clear feedback:</p> </li> <li>Shows [OK] for successful checks</li> <li>Shows [WARNING] for missing optional files with option to continue</li> <li>Shows [ERROR] for critical missing components</li> <li> <p>Displays helpful troubleshooting tips on failure</p> </li> <li> <p>Runs the tool:</p> </li> <li>Activates the virtual environment</li> <li>Executes the main script</li> <li>Captures and displays the exit code</li> <li>Provides common troubleshooting tips if errors occur</li> </ol>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#example-output","title":"Example Output","text":"<pre><code>================================================================================\n                  ACCESS SWITCH AUDIT TOOL\n================================================================================\n\nStarting validation checks...\n\n[OK] Python Environment: Found at portable_env\\Scripts\\python.exe\n[OK] Required support files found\n[OK] All validation checks passed\n\n================================================================================\n\nRunning Access Switch Audit...\n\n================================================================================\n\n[Script output appears here]\n\n================================================================================\n\n[SUCCESS] Script completed successfully\n\n================================================================================\n</code></pre>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#advanced-command-line-with-arguments","title":"\ud83d\ude80 Advanced: Command Line with Arguments","text":"<p>For advanced users who need to customize behavior beyond the defaults, you can still run the tool directly with Python and command-line arguments.</p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#when-to-use-command-line-arguments","title":"When to Use Command Line Arguments","text":"<p>Use <code>python main.py</code> with arguments when you need to:</p> <ul> <li>Override default settings from <code>config.yaml</code></li> <li>Specify a different devices file</li> <li>Change output filename</li> <li>Adjust worker thread count</li> <li>Enable debug mode</li> <li>Force direct connections (bypass jump host)</li> </ul>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#method-1-using-the-launcher-with-arguments","title":"Method 1: Using the Launcher with Arguments","text":"<p>You can pass arguments to <code>run.bat</code> and they will be forwarded to the Python script:</p> <pre><code>run.bat --devices my-switches.txt --output custom-audit.xlsx --workers 5\n</code></pre>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#method-2-direct-python-execution","title":"Method 2: Direct Python Execution","text":"<p>Activate the virtual environment and run Python directly:</p> <pre><code># Windows\nportable_env\\Scripts\\activate\npython main.py --devices my-switches.txt --output audit-report.xlsx\n\n# Linux/macOS  \nsource portable_env/bin/activate\npython main.py --devices my-switches.txt --output audit-report.xlsx\n</code></pre>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#available-command-line-arguments","title":"Available Command-Line Arguments","text":"Argument Description Default <code>--devices</code>, <code>-d</code> Path to devices file <code>devices.txt</code> <code>--output</code>, <code>-o</code> Output Excel filename <code>audit.xlsx</code> <code>--workers</code>, <code>-w</code> Number of concurrent threads 10 <code>--stale-days</code> Days threshold for stale ports 30 <code>--direct</code> Skip jump host, connect directly False <code>--debug</code> Enable debug-level logging False <p>Example: Custom audit with direct connections:</p> <pre><code>python main.py --devices critical-switches.txt --output critical-audit.xlsx --direct --debug\n</code></pre>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#technical-architecture","title":"\ud83c\udfd7\ufe0f Technical Architecture","text":"<p>The tool operates as a modular Python application with six primary components:</p> Component Responsibility Why It Matters Config Loader YAML parsing and validation with type-safe properties Settings are centralized, validated, and safe from code injection CredentialManager Secure credential retrieval from OS stores Passwords never touch plaintext or config files JumpManager Persistent SSH tunnelling through a bastion host Centralises network access control; supports air-gapped environments PortAuditor (Netmiko) Parallel device SSH connections and command collection Audits 20+ switches in minutes, not hours PortIntelligence Multi-source port classification and risk flagging Detects stale, misconfigured, or problematic ports automatically ExcelReporter Professional, templated workbook generation Operations teams get insights immediately, not raw data dumps","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#key-design-patterns","title":"Key Design Patterns","text":"<p>1. Modular Configuration: - Settings separated from code (YAML vs Python) - Config loader provides validation and type safety - Environment-specific overrides supported</p> <p>2. Intelligent Fallback Parsing: - Primary: TextFSM templates (when available) - Fallback: Custom fixed-width parsers - Ensures reliability even without external dependencies</p> <p>3. Multi-Threaded Execution: - ThreadPoolExecutor with configurable worker count - Thread-safe data accumulation with locks - Per-device failure isolation</p> <p>4. Graceful Error Handling: - Exponential backoff retry logic - Per-device error capture (doesn't stop entire audit) - Comprehensive logging for troubleshooting</p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#intelligent-parsing-the-heart-of-the-tool","title":"\ud83d\udcca Intelligent Parsing: The Heart of the Tool","text":"","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#why-intelligent-parsing-matters","title":"Why Intelligent Parsing Matters","text":"<p>The Problem: Cisco CLI output varies by device model, IOS version, and platform. <code>show interfaces status</code> might be formatted differently on a Catalyst 2960 vs a 9300. TextFSM templates might not exist for your specific platform.</p> <p>The Solution: Multi-tier parsing strategy with intelligent fallbacks.</p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#parsing-strategy-textfsm-custom-fallback","title":"Parsing Strategy: TextFSM + Custom Fallback","text":"<pre><code>def get_interfaces_via_show_interfaces(conn) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Use TextFSM to parse 'show interfaces' for all ports.\n    Falls back gracefully if templates unavailable.\n    \"\"\"\n    try:\n        output = conn.send_command(\"show interfaces\", use_textfsm=True)\n        if isinstance(output, list):\n            return output\n        return []\n    except Exception:\n        return []  # Graceful degradation\n</code></pre> <p>Why This Approach: - TextFSM provides structured parsing when templates exist - Returns empty list (not exception) if parsing fails - Main logic continues with custom parsers</p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#custom-fixed-width-parser-parse_show_interfaces_status","title":"Custom Fixed-Width Parser: <code>parse_show_interfaces_status()</code>","text":"<p>This is the authoritative source for port mode and VLAN classification.</p> <pre><code>def parse_show_interfaces_status(output: str) -&gt; List[Dict[str, str]]:\n    \"\"\"\n    Robust fixed-width parser for 'show interfaces status'.\n    Handles:\n    - Multiple header formats\n    - Variable column widths\n    - Missing/malformed data\n    \"\"\"\n</code></pre> <p>Step 1: Identify Header Row</p> <pre><code>def is_header(ln: str) -&gt; bool:\n    return (\"Port\" in ln and \"Status\" in ln and \"Vlan\" in ln and \"Speed\" in ln)\n</code></pre> <p>Why: Header detection must be flexible. Different IOS versions capitalize differently.</p> <p>Step 2: Extract Column Positions</p> <pre><code>def _find_columns(header_line: str) -&gt; Dict[str, slice]:\n    \"\"\"\n    Calculate exact character positions for each column.\n    Returns slice objects for substring extraction.\n    \"\"\"\n    tokens = [\"Port\", \"Name\", \"Status\", \"Vlan\", \"Duplex\", \"Speed\", \"Type\"]\n    positions = {}\n    for i, tok in enumerate(tokens):\n        start = header_line.find(tok)\n        end = header_line.find(tokens[i+1]) if i+1 &lt; len(tokens) else len(header_line)\n        positions[tok.lower()] = slice(start, end)\n    return positions\n</code></pre> <p>Why This Matters: - Fixed-width parsing is more reliable than regex for tabular CLI output - Dynamically calculated positions adapt to slight formatting variations - Slice objects provide clean substring extraction</p> <p>Step 3: Parse Data Rows</p> <pre><code>for line in lines:\n    if line.startswith((\"--\", \"Port\")) or not line.strip():\n        continue  # Skip separators and empty lines\n\n    record = {}\n    for key, col_slice in slices.items():\n        record[key] = line[col_slice].strip()\n\n    # Normalize status values\n    status_raw = record.get('status', '').lower()\n    if 'connect' in status_raw:\n        record['status'] = 'connected'\n    elif 'notconnect' in status_raw:\n        record['status'] = 'notconnect'\n    elif 'disabled' in status_raw:\n        record['status'] = 'disabled'\n    elif 'err' in status_raw:\n        record['status'] = 'err-disabled'\n</code></pre> <p>Why Status Normalization: - Different IOS versions use slight variations (\"connected\" vs \"connect\") - Normalized values enable reliable conditional formatting in Excel - Consistent categorization across device types</p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#port-mode-classification","title":"Port Mode Classification","text":"<pre><code># Determine mode from VLAN column\nvlan_value = record.get('vlan', '').lower()\n\nif vlan_value in ('trunk', 'rspan'):\n    mode = 'trunk'\nelif vlan_value == 'routed':\n    mode = 'routed'\nelse:\n    mode = 'access'  # Default assumption\n</code></pre> <p>Why This Logic: - VLAN column is the most reliable indicator of port mode - Trunk ports show \"trunk\" or \"rspan\" in VLAN field - Routed ports show \"routed\" - Everything else is access (may show VLAN number)</p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#poe-enrichment-multi-source-data-fusion","title":"\ud83d\udd0c PoE Enrichment: Multi-Source Data Fusion","text":"","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#the-poe-challenge","title":"The PoE Challenge","text":"<p>Problem: PoE data (<code>show power inline</code>) uses different interface naming than <code>show interfaces status</code>. Example: - Status command: <code>Gi1/0/1</code> - PoE command: <code>GigabitEthernet1/0/1</code></p> <p>Solution: Interface name aliasing and multi-key lookups.</p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#interface-name-normalization","title":"Interface Name Normalization","text":"<pre><code>def normalize_ifname(ifname: str) -&gt; Tuple[str, str]:\n    \"\"\"\n    Normalize interface names to canonical short and long forms.\n    Returns: (short_form, long_form)\n    Example: \"Gi1/0/1\" \u2192 (\"Gi1/0/1\", \"GigabitEthernet1/0/1\")\n    \"\"\"\n    # Extract prefix and port number\n    m = re.match(r\"([A-Za-z]+)([0-9/\\.]+.*)\", ifname)\n    if not m:\n        return (ifname, ifname)\n\n    prefix_raw = m.group(1)\n    rest = m.group(2)\n\n    # Map to short form\n    short_prefix = _IF_MAP.get(prefix_raw.lower(), prefix_raw)\n\n    # Generate long form\n    long_prefix = {\n        \"Gi\": \"GigabitEthernet\",\n        \"Fa\": \"FastEthernet\",\n        \"Te\": \"TenGigabitEthernet\",\n        \"Eth\": \"Ethernet\",\n    }.get(short_prefix, prefix_raw)\n\n    return (f\"{short_prefix}{rest}\", f\"{long_prefix}{rest}\")\n</code></pre> <p>Why This Matters: - Enables reliable cross-command matching - Handles all common Cisco interface types - Works across different IOS versions and platforms</p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#alias-based-lookup","title":"Alias-Based Lookup","text":"<pre><code>def all_aliases(ifname: str) -&gt; List[str]:\n    \"\"\"\n    Return all possible alias strings for an interface.\n    Used for PoE data matching.\n    \"\"\"\n    short, long = normalize_ifname(ifname)\n    return [short, long, ifname]  # Try all variations\n\n# During PoE enrichment:\nfor alias in all_aliases(port_name):\n    if alias in poe_map:\n        poe_data = poe_map[alias]\n        break\n</code></pre> <p>Why Multiple Aliases: - Different commands use different naming conventions - Maximizes successful PoE data correlation - Prevents data loss due to naming mismatches</p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#stale-port-detection-conservative-risk-assessment","title":"\ud83d\udea8 Stale Port Detection: Conservative Risk Assessment","text":"","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#the-business-problem","title":"The Business Problem","text":"<p>Scenario: You have 1,000 switch ports. How do you identify which ones are truly unused vs. temporarily disconnected vs. connected to equipment that's powered off?</p> <p>False Positives Are Expensive: - Marking an active port as \"stale\" disrupts operations - Users lose network access - Help desk tickets spike</p> <p>False Negatives Waste Resources: - Unused ports consume switch capacity - Security risk (unauthorized devices can plug in)</p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#conservative-detection-strategy","title":"Conservative Detection Strategy","text":"<pre><code>def _categorize_port(row: Dict[str, Any], stale_days: int) -&gt; str:\n    \"\"\"\n    Classify port as: active, stale, or available.\n    Uses conservative logic to minimize false positives.\n    \"\"\"\n</code></pre> <p>Rule 1: Only Classify Access Ports</p> <pre><code>mode = row.get('Mode', '')\nif mode != 'access':\n    return 'active'  # Trunk and routed ports are infrastructure\n</code></pre> <p>Why: Trunk and routed ports connect switches to each other. They should never be flagged as stale.</p> <p>Rule 2: Connected Ports \u2014 Check Activity</p> <pre><code>status = row.get('Status', '')\nif status == 'connected':\n    last_input_secs = row.get('Last Input Seconds')\n    if last_input_secs and last_input_secs &gt;= (stale_days * 86400):\n        return 'stale'\n    return 'active'\n</code></pre> <p>Why: - Port is physically connected - But hasn't passed traffic in N days - Likely a powered-off device or misconfigured endpoint</p> <p>Rule 3: Disconnected Ports \u2014 Check for Indicators</p> <pre><code>if status in ('notconnect', 'disabled', 'err-disabled'):\n    # Conservative: require BOTH conditions to flag as stale\n    has_poe = row.get('PoE Power (W)')\n    has_neighbor = row.get('LLDP/CDP Neighbor')\n\n    poe_w = None\n    if has_poe:\n        try:\n            poe_w = float(str(has_poe).split()[0])\n        except:\n            pass\n\n    # Stale only if: no PoE draw AND no neighbor\n    if (poe_w is None or poe_w == 0.0) and not has_neighbor:\n        return 'stale'\n\n    return 'available'  # May be in use (PoE or neighbor present)\n</code></pre> <p>Why This Conservative Approach:</p> Indicator Interpretation PoE draw &gt; 0 Device is powered (IP phone, camera, AP) LLDP/CDP neighbor Device is network-aware (switch, phone, AP) Both absent Likely unused cable or dead device <p>Example Scenarios:</p> Status PoE Neighbor Last Input Classification Reasoning connected 7.0W Yes 10 days active IP phone actively drawing power connected 0W No 45 days stale Connected but no traffic for 45+ days notconnect 0W No N/A stale Disconnected, no indicators of use notconnect 6.5W No N/A available PoE device present (might be powered off) notconnect 0W Yes N/A available Neighbor detected (might be rebooting)","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#time-parsing-handling-cisco-duration-formats","title":"Time Parsing: Handling Cisco Duration Formats","text":"<pre><code>def _parse_last_input_seconds(s: str) -&gt; float | None:\n    \"\"\"\n    Parse Cisco 'Last input' timer into seconds.\n    Handles: \"00:01:23\", \"1d2h30m\", \"never\"\n    \"\"\"\n    s = (s or \"\").strip().lower()\n    if not s or s == \"never\":\n        return None\n\n    # Format 1: hh:mm:ss\n    if re.match(r\"^\\d{1,2}:\\d{2}:\\d{2}$\", s):\n        hh, mm, ss = s.split(\":\")\n        return int(hh) * 3600 + int(mm) * 60 + int(ss)\n\n    # Format 2: Compact duration (1y2w3d4h5m6s)\n    m = _TIME_RE.fullmatch(s.replace(\" \", \"\"))\n    if m:\n        y = int(m.group(\"y\") or 0)\n        w = int(m.group(\"w\") or 0)\n        d = int(m.group(\"d\") or 0)\n        h = int(m.group(\"h\").rstrip(\"h\") or 0)\n        m_val = int(m.group(\"m\").rstrip(\"m\") or 0)\n        s_val = int(m.group(\"s\").rstrip(\"s\") or 0)\n\n        days = y * 365 + w * 7 + d\n        return days * 86400 + h * 3600 + m_val * 60 + s_val\n</code></pre> <p>Why Multiple Format Support: - Different IOS versions use different time formats - Ensures accurate stale detection across all platforms</p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#credentials-security","title":"\ud83d\udd10 Credentials &amp; Security","text":"<p>The script retrieves device credentials using <code>Modules/credentials.py</code>:</p> <ul> <li>Primary: Windows Credential Manager (target name from <code>config.yaml</code>: default <code>MyApp/ADM</code>)</li> <li>Fallback: Interactive prompt for username and password (secure, not echoed)</li> <li>Enable secret: Retrieved by <code>get_enable_secret()</code> if configured in <code>config.yaml</code>, otherwise not required</li> </ul> <p>Note: If you are running on Linux/macOS, ensure <code>credentials.py</code> prompts for credentials or implements your preferred secure store. On Windows, <code>pywin32</code> enables Credential Manager access.</p> <p>Important: Never hard-code credentials in the repository. Use the secure store or environment prompts.</p> <p>Configuration: Credential Manager targets are set in <code>config.yaml</code> under the <code>credentials</code> section:</p> <pre><code>credentials:\n  cred_target: \"MyApp/ADM\"  # Primary credential target\n  enable_target: \"\"          # Optional enable secret target\n</code></pre>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#jump-host-bastion-behaviour","title":"\ud83d\udef0\ufe0f Jump Host (Bastion) Behaviour","text":"<ul> <li><code>main.py</code> reads <code>jump_host</code> from the <code>network</code> section of <code>config.yaml</code></li> <li>Default: the script uses the jump host if <code>--direct</code> is not supplied</li> <li><code>--direct</code> will skip the jump host entirely and attempt direct SSH connections</li> </ul> <p>Example configuration in <code>config.yaml</code>: <pre><code>network:\n  jump_host: \"jump-gateway.example.com\"  # or \"\" to disable by default\n</code></pre></p> <p>The <code>JumpManager</code> maintains a persistent SSH session to the bastion and proxies device connections through it.</p> <p>How JumpManager Works:</p> <pre><code>class JumpManager:\n    def __init__(self, jump_host: str, username: str, password: str):\n        self.jump_host = jump_host\n        self.username = username\n        self.password = password\n        self.client = None  # Paramiko SSH client\n\n    def connect(self) -&gt; None:\n        \"\"\"Establish persistent SSH connection to bastion.\"\"\"\n        self.client = paramiko.SSHClient()\n        self.client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n        self.client.connect(\n            self.jump_host,\n            username=self.username,\n            password=self.password,\n            timeout=10\n        )\n\n    def open_channel(self, target_ip: str, target_port: int):\n        \"\"\"Open direct-tcpip channel through bastion.\"\"\"\n        return self.client.get_transport().open_channel(\n            'direct-tcpip',\n            (target_ip, target_port),\n            ('localhost', 0)\n        )\n</code></pre> <p>Why direct-tcpip Channel: - No port forwarding needed on bastion - All traffic stays within authenticated SSH session - Cleaner than local port forwarding - Works with restrictive bastion configurations</p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#device-list-file","title":"\ufffd\ufe0f Device List File","text":"<p>Provide a plain-text file with one device per line. Lines that are blank or start with <code>#</code> are ignored.</p> <pre><code># devices.txt\n192.0.2.11\n192.0.2.12  # inline comments are not parsed; this whole token must be a host/IP only\ncore-switch-01\naccess-sw-22\n</code></pre> <p>Note: Hostnames must be resolvable from the machine (or via the jump host, depending on your SSH setup).</p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#quick-start","title":"\ud83d\ude80 Quick Start","text":"<ol> <li>Install dependencies (see Requirements).</li> <li>Create <code>devices.txt</code> with your targets (see Device list file).</li> <li>(Optional) Configure <code>Modules/config.py</code> with your <code>JUMP_HOST</code>.</li> <li>Run the audit:</li> </ol> <pre><code># Using jump host from config.yaml\npython -m main --devices devices.txt --output access_port_audit.xlsx\n\n# Direct connections (no bastion), 5 workers, different stale threshold\npython -m main --direct -w 5 --stale-days 60 -d devices.txt -o results.xlsx\n\n# Verbose debugging\npython -m main --debug -d devices.txt\n</code></pre>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#cli-reference","title":"\ud83e\udded CLI Reference","text":"<p><code>main.py</code> exposes the following command-line options:</p> <pre><code>--devices, -d    (required)  Path to the devices file (one IP/hostname per line; '#' comments allowed)\n--output,  -o    (optional)  Output Excel file name. Default: audit.xlsx\n--workers, -w    (optional)  Max concurrent device sessions (threads). Default: 10\n--stale-days     (optional)  Days threshold for stale access ports. 0 disables stale flagging. Default: 30\n--direct         (optional)  Connect directly (do not use jump host)\n--debug          (optional)  Enable verbose logging/prints\n</code></pre>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#required-vs-optional","title":"Required vs Optional","text":"<ul> <li>Required: <code>--devices</code></li> <li>Optional: everything else</li> </ul>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#portauditor-the-threaded-collection-engine","title":"\ufffd\ud83d\udd0c PortAuditor: The Threaded Collection Engine","text":"","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#why-parallel-port-auditing-is-essential","title":"Why Parallel Port Auditing is Essential","text":"<p>The Problem: Auditing 50 switches serially with 5 commands per device = 250 SSH round-trips. At 2 seconds per connection, that's 8+ minutes of waiting.</p> <p>The Solution: Thread pool with 10 concurrent workers = 10 simultaneous SSH sessions. Same 50 switches audited in 1-2 minutes.</p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#thread-safe-architecture","title":"Thread-Safe Architecture","text":"<pre><code># Thread-safe accumulators (protected by locks)\nself.device_records = []       # Parsed results: one row per device\nself.interface_details = []    # Detailed per-interface data\nself.failed_devices = {}       # {ip: error_message}\nself.progress_lock = threading.Lock()  # Protects shared state\n</code></pre> <p>Why Thread Locks Matter: - Without locks, multiple threads writing to the same list causes data corruption - The lock ensures atomic append operations - Minimal lock contention because we hold locks for microseconds, not seconds</p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#command-collection-strategy","title":"Command Collection Strategy","text":"<p>For each device, the tool collects five commands in sequence:</p> Command Purpose Fallback <code>show version</code> Extract hostname, OS version, uptime Use management IP if hostname parse fails <code>show interfaces</code> Parse interface types, error counters, activity Use TextFSM if available; use internal parser otherwise <code>show interfaces status</code> Extract port mode, VLAN, status using fixed-width parsing Built-in fallback parser (no external dependency) <code>show power inline</code> Collect PoE admin/oper state and power draw Empty dict if device is non-PoE or command fails <code>show cdp/lldp neighbors detail</code> Detect peer devices on each port Boolean flag (true if neighbour present) <p>Why This Command Set? - Comprehensive but minimal: each command provides data no other command offers - Covers the three dimensions of port health: configuration (mode/VLAN), activity (errors, last input), attachment (PoE, neighbours)</p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#the-intelligence-layer-port-classification","title":"The Intelligence Layer: Port Classification","text":"<pre><code>def classify_port(interface_record):\n    \"\"\"\n    Assign a port to one of three categories:\n    - 'access': Single VLAN, typically hosts\n    - 'trunk': Multiple VLANs, typically uplinks\n    - 'routed': No VLAN (layer 3), typically inter-device links\n    \"\"\"\n</code></pre> <p>Classification Logic:</p> <p>From <code>show interfaces status</code>, inspect the VLAN column:</p> <ul> <li>If <code>trunk</code> or <code>rspan</code> \u2192 Trunk</li> <li>If <code>routed</code> \u2192 Routed</li> <li>Otherwise \u2192 Access</li> </ul> <p>Why This Matters: - Different port types require different stale-detection rules - Access ports should be connected to hosts; trunk ports connect infrastructure - This classification enables intelligent filtering and reporting</p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#stale-logic-how-ports-are-flagged","title":"\ud83d\uded1 Stale Logic \u2014 How Ports Are Flagged","text":"<p>A conservative approach is used only for ports in <code>access</code> mode and when <code>--stale-days &gt; 0</code>:</p> <ul> <li>If Status = <code>connected</code> \u2192 mark stale = True only if <code>Last input \u2265 &lt;stale-days&gt;</code></li> <li>If Status \u2260 <code>connected</code> \u2192 mark stale = True when both conditions hold:</li> <li>No PoE draw (PoE power is blank/<code>-</code>/0.0), and</li> <li>No LLDP/CDP neighbour present on the port</li> </ul> <p>This tends to avoid false positives on trunk/routed ports and on access ports actively in use.</p> <p>Note: You can disable stale flagging entirely by setting <code>--stale-days 0</code>.</p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#what-the-script-collects","title":"\ud83e\uddea What the Script Collects","text":"<p>For each device the script attempts to gather:</p> <ul> <li>Hostname (from <code>show running-config | include ^hostname</code> or CLI prompt fallback)</li> <li>Interfaces via TextFSM (<code>show interfaces</code>) when available</li> <li>Port mode &amp; VLAN via a robust, fixed-width parser of <code>show interfaces status</code></li> <li>PoE details: admin/oper state, power draw (W), class, device (<code>show power inline</code>)</li> <li>Neighbour presence: LLDP/CDP seen on the port (boolean)</li> <li>Error counters: input, output, CRC (from <code>show interfaces</code> parsed data)</li> <li>Activity indicator: \"Last input\" time (seconds parsed when present)</li> </ul>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#excel-output-structure","title":"\ud83d\udce4 Excel Output Structure","text":"<p>The workbook contains:</p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#1-summary-sheet-first","title":"1) <code>SUMMARY</code> Sheet (First)","text":"<ul> <li>One row per device, with a final TOTAL row (sums numeric columns)</li> <li>Columns include:</li> <li><code>Device</code>, <code>Mgmt IP</code>, <code>Total Ports (phy)</code></li> <li><code>Access Ports</code>, <code>Trunk Ports</code>, <code>Routed Ports</code></li> <li><code>Connected</code>, <code>Not Connected</code>, <code>Admin Down</code>, <code>Err-Disabled</code></li> <li><code>% Access of Total</code>, <code>% Trunk of Total</code>, <code>% Routed of Total</code>, <code>% Connected of Total</code></li> </ul>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#2-one-sheet-per-device","title":"2) One Sheet Per Device","text":"<p>Columns typically include (when available):</p> <ul> <li><code>Device</code>, <code>Mgmt IP</code>, <code>Interface</code> (long form), <code>Description</code></li> <li><code>Status</code> (normalised: connected / notconnect / administratively down / err-disabled)</li> <li><code>AdminDown</code>, <code>Connected</code>, <code>ErrDisabled</code> (booleans for quick filters)</li> <li><code>Mode</code> (access/trunk/routed), <code>VLAN</code></li> <li><code>Duplex</code>, <code>Speed</code>, <code>Type</code></li> <li><code>Input Errors</code>, <code>Output Errors</code>, <code>CRC Errors</code></li> <li><code>Last Input</code> (raw text)</li> <li><code>PoE Power (W)</code>, <code>PoE Oper</code>, <code>PoE Admin</code></li> <li><code>LLDP/CDP Neighbour</code> (boolean)</li> <li><code>Stale (\u2265&lt;N&gt; d)</code> (boolean)</li> </ul>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#formatting","title":"Formatting","text":"<ul> <li>Frozen header (<code>A2</code>) and AutoFilter across all columns</li> <li>Auto-sized columns with sensible min/max widths</li> <li>Conditional formatting:</li> <li><code>Status = connected</code> \u2192 green</li> <li><code>Status = notconnect</code> / <code>err-disabled</code> \u2192 red</li> <li><code>Status = administratively down</code> \u2192 grey</li> <li>Any <code>*Errors</code> &gt; 0 \u2192 red</li> <li><code>PoE Power (W)</code> &gt; 0 \u2192 green</li> <li><code>Stale (\u2265N d)</code> = TRUE \u2192 red</li> </ul>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#performance-concurrency","title":"\u2699\ufe0f Performance &amp; Concurrency","text":"<ul> <li>Uses a <code>ThreadPoolExecutor</code> with <code>--workers</code> threads (default 10)</li> <li>An event-driven progress bar updates as jobs start/finish</li> <li>Each device is independent; a failure on one does not stop others</li> </ul> <p>The script prints an event-driven progress bar like:</p> <pre><code>Progress: [\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591] 12/30 started: 15/30\n</code></pre> <p>On completion, the Excel workbook is written to the filename you specify (default <code>audit.xlsx</code>).</p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#logging-debug-and-errors","title":"\ufffd Logging, Debug, and Errors","text":"<ul> <li>Add <code>--debug</code> to surface additional prints (e.g., enable mode attempts, jump host info, file counts)</li> <li>Per-device errors are captured into the device's summary row (and a minimal sheet may be created with the error text so the workbook always reflects all devices)</li> </ul> <p>Common runtime issues &amp; tips:</p> <ul> <li>Authentication failures \u2192 check Credential Manager entry or typed credentials</li> <li>SSH connectivity \u2192 verify reachability from the workstation or via the jump host</li> <li>TextFSM templates missing \u2192 parsing still proceeds, but some fields may be blank</li> <li>Channel/line rate limits on older devices \u2192 consider lowering <code>--workers</code></li> </ul>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#extending-and-customizing","title":"\ud83d\udd27 Extending and Customizing","text":"<ul> <li>Credentials: Adapt <code>Modules/credentials.py</code> to your environment (Linux keyring, Azure Key Vault, etc.)</li> <li>Jump host: Tune <code>Modules/jump_manager.py</code> (keep-alive, ciphers, auth methods) as needed</li> <li>Connection behaviour: Modify <code>Modules/netmiko_utils.py</code> for device types, timeouts, or SSH options</li> <li>Configuration: Edit <code>config.yaml</code> to set organizational defaults:</li> <li><code>network.jump_host</code>: Default bastion server</li> <li><code>concurrency.default_workers</code>: Concurrent device sessions</li> <li><code>stale_detection.default_stale_days</code>: Stale port threshold</li> <li><code>credentials.cred_target</code>: Credential Manager target name</li> <li><code>output.default_filename</code>: Default Excel output filename</li> <li>Output columns: Adjust record construction in <code>main.py</code> (search for <code>detailed.append({...})</code>)</li> <li>Conditional formatting: Tweak <code>_format_worksheet()</code> in <code>main.py</code></li> <li>Parsers: Modify <code>parse_show_interfaces_status()</code> or <code>parse_show_power_inline()</code> for custom parsing logic</li> </ul> <p>Example config.yaml for Enterprise:</p> <pre><code>network:\n  jump_host: \"bastion.corp.example.com\"\n  read_timeout: 45  # Slower WAN links\n\ncredentials:\n  cred_target: \"NetworkAudit/Production\"\n\nconcurrency:\n  default_workers: 20  # Fast discovery\n  retry_attempts: 5    # More retries for flaky network\n\nstale_detection:\n  default_stale_days: 90  # Longer threshold\n\noutput:\n  default_filename: \"port_audit_report.xlsx\"\n\nexcel_formatting:\n  min_column_width: 12\n  max_column_width: 60\n</code></pre>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#security-considerations","title":"\ud83d\udd12 Security Considerations","text":"<ul> <li>Prefer secure stores over plaintext</li> <li>Limit who can run the tool and who can read the generated Excel</li> <li>When using a jump host, ensure strong authentication and proper network segmentation</li> </ul>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#compatibility","title":"\ud83e\udde9 Compatibility","text":"<ul> <li>Target devices: Cisco IOS/IOS-XE access and distribution switches reachable via SSH</li> <li>The tool relies on Netmiko; specify the right device type(s) inside <code>netmiko_utils.py</code></li> <li>TextFSM/NTC templates significantly improve interface parsing fidelity but are not strictly required</li> </ul>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#tested-devices","title":"Tested Devices","text":"<p>This tool has been tested and verified on the following Cisco IOS and IOS-XE platforms:</p> <ul> <li>Catalyst 9200 Series</li> <li>Catalyst 3650 Series</li> <li>Catalyst 3650C</li> <li>Catalyst 3650CG</li> <li>Catalyst 3650CX</li> <li>Catalyst 2960X Series</li> <li>Catalyst 2960 Series</li> </ul> <p>Note: The tool should work with any Cisco IOS/IOS-XE device that supports the required show commands (interfaces, status, power inline, CDP/LLDP). The devices listed above have been explicitly tested and validated.</p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#examples","title":"\u2705 Examples","text":"<pre><code># Basic, with jump host\npython -m main -d devices.txt -o audit.xlsx\n\n# Direct (no bastion), 20 workers, stale disabled\npython -m main --direct -w 20 --stale-days 0 -d devices.txt -o audit.xlsx\n\n# Conservative concurrency, higher stale threshold, verbose\npython -m main -w 4 --stale-days 90 --debug -d devices.txt -o siteA.xlsx\n</code></pre>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#faqs","title":"\ud83e\udde0 FAQs","text":"<p>Q: Do I need NTC TextFSM templates? A: They are recommended for better <code>show interfaces</code> parsing. Without them, the script still works and uses its internal parser for <code>show interfaces status</code> and best-effort logic elsewhere.</p> <p>Q: Where do credentials come from? A: On Windows, from Credential Manager (default target <code>MyApp/ADM</code>). Otherwise, you are prompted interactively or you can adapt <code>credentials.py</code> to your secret store.</p> <p>Q: How is <code>Mode</code> determined? A: From <code>show interfaces status</code>: if VLAN column is <code>trunk</code>/<code>rspan</code> \u2192 <code>trunk</code>; if <code>routed</code> \u2192 <code>routed</code>; otherwise <code>access</code>.</p> <p>Q: How is a port considered stale? A: Only for access ports and when <code>--stale-days &gt; 0</code>. Connected ports are flagged stale only if <code>Last input \u2265 N days</code>. Disconnected ports require both no PoE draw and no LLDP/CDP neighbour to be flagged stale.</p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#learning-outcomes","title":"\ud83c\udf93 Learning Outcomes","text":"<p>After studying this code, you should understand:</p> <p>\u2705 YAML Configuration Management \u2014 How to separate configuration from code using YAML with Python \u2705 Fixed-Width Parsing \u2014 Reliable CLI output parsing without external dependencies \u2705 Multi-Source Data Fusion \u2014 Correlating data across different commands using interface name aliasing \u2705 Conservative Risk Assessment \u2014 Stale port detection logic that minimizes false positives \u2705 Thread-Safe Concurrency \u2014 Parallel device audits with proper lock management \u2705 Intelligent Fallback Strategy \u2014 TextFSM + custom parsers for maximum compatibility \u2705 SSH Tunneling \u2014 Jump host integration with Paramiko direct-tcpip channels \u2705 Excel Automation \u2014 Professional workbook generation with conditional formatting \u2705 Exponential Backoff \u2014 Retry logic for transient network failures \u2705 Credential Management \u2014 Secure OS-level credential storage integration  </p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#key-code-patterns-demonstrated","title":"Key Code Patterns Demonstrated","text":"<p>Pattern 1: Graceful Degradation <pre><code>try:\n    data = parse_with_textfsm(output)  # Preferred method\nexcept:\n    data = parse_with_custom_logic(output)  # Fallback\n</code></pre></p> <p>Pattern 2: Multi-Key Lookup <pre><code>for alias in all_aliases(interface_name):\n    if alias in poe_map:\n        poe_data = poe_map[alias]\n        break\n</code></pre></p> <p>Pattern 3: Thread-Safe Accumulation <pre><code>with lock:\n    results.append(new_data)  # Atomic operation\n</code></pre></p> <p>Pattern 4: Conservative Classification <pre><code>if condition_A and condition_B:  # Both must be true\n    mark_as_risky()\nelse:\n    mark_as_safe()  # Default to safe\n</code></pre></p> <p>Pattern 5: Type-Safe Configuration <pre><code>@property\ndef default_workers(self) -&gt; int:\n    return self._get_nested(\"concurrency\", \"default_workers\", default=10)\n</code></pre></p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#distribution-execution","title":"\ud83d\ude80 Distribution &amp; Execution","text":"<p>Consistent with the Nautomation Prime delivery model, this tool is available in multiple formats:</p> <ul> <li> <p>Zero-Install Portable Bundle: A self-contained package including the Python interpreter and all libraries (Netmiko, Pandas, OpenPyXL) for use on restricted Windows jump boxes.</p> </li> <li> <p>Scheduled Docker Appliance: A pre-built container designed for autonomous execution and periodic port auditing.</p> </li> <li> <p>Source Code: Full access to customize parsing logic, add vendor-specific commands, or integrate with your CMDB.</p> </li> </ul>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#licence","title":"\ud83d\udccb Licence","text":"<p>GNU General Public Licence v3.0</p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/access-switch-audit/#author","title":"\ud83d\udc64 Author","text":"<p>Christopher Davies</p> <p>Mission: To empower network engineers with transparent, hardened Python tools that eliminate manual audits and expose infrastructure health at a glance.</p>","tags":["Deep Dive","Access Switch","Port Audit","PoE","Excel","YAML"]},{"location":"deep-dives/cdp-audit/","title":"Deep Dive: CDP Network Audit Tool","text":"","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#cisco-python-automation-explained-line-by-line","title":"\"Cisco Python Automation, Explained Line-by-Line.\"","text":"<p>A threaded network discovery utility that starts from one or more seed Cisco devices and crawls the topology via Cisco Discovery Protocol (CDP). It connects (optionally through an SSH jump/bastion host), collects <code>show cdp neighbors detail</code> and <code>show version</code>, parses outputs with TextFSM, enriches with DNS resolution, and writes a structured Excel report from a pre-formatted template. Designed for reliability, safe concurrency, and repeatable reporting in enterprise environments.</p> <p> View Source Code on GitHub</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#highlights","title":"\u2728 Highlights","text":"<ul> <li>Parallel discovery with a worker pool (configurable via <code>config.py</code> or environment variables)</li> <li>Two-tier authentication: primary user first, then customisable fallback user if primary fails</li> <li>Jump server / bastion support (Paramiko channel + Netmiko sock)</li> <li>DNS enrichment for discovered hostnames</li> <li>Excel report written from a pre-formatted template with multiple sheets</li> <li>Hybrid logging: optional <code>logging.conf</code>; sensible defaults otherwise</li> <li>Centralized configuration via comprehensive <code>config.py</code> with 200+ lines of documented settings</li> <li>Fully customisable including fallback username, credential targets, jump host, Excel formatting, and more</li> </ul>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#the-nautomation-prime-philosophy-in-action","title":"\ud83c\udfaf The Nautomation Prime Philosophy in Action","text":"<p>Before diving into the code, understand how every design decision reflects our three core principles:</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#principle-1-line-by-line-transparency","title":"Principle 1: Line-by-Line Transparency","text":"<p>Every function in this tool is extensively documented. We don't just explain what the code does\u2014we explain why it's structured this way and what engineering tradeoffs we made.</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#principle-2-hardened-for-production","title":"Principle 2: Hardened for Production","text":"<p>You'll notice patterns like thread locks, exception handling, retry logic, and graceful cleanup. These aren't \"nice to have\"\u2014they're essential for running automation on critical infrastructure without surprises.</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#principle-3-vendor-neutral","title":"Principle 3: Vendor-Neutral","text":"<p>This tool is built on industry-standard libraries: Netmiko (SSH connection handling), Paramiko (SSH tunnelling), Pandas &amp; OpenPyXL (Excel reporting), and TextFSM (parsing). Your skills remain portable.</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#repository-layout-expected","title":"\ud83e\uddf1 Repository Layout (Expected)","text":"<pre><code>.\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 config.yaml                  # YAML configuration file (NEW!)\n\u251c\u2500\u2500 .vscode/\n\u2514\u2500\u2500 ProgramFiles/\n    \u251c\u2500\u2500 textfsm/\n    \u2502   \u251c\u2500\u2500 cisco_ios_show_cdp_neighbors_detail.textfsm\n    \u2502   \u2514\u2500\u2500 cisco_ios_show_version.textfsm\n    \u2514\u2500\u2500 config_files/\n        \u251c\u2500\u2500 config_loader.py       # Python class to load config.yaml\n        \u251c\u2500\u2500 1 - CDP Network Audit _ Template.xlsx\n        \u2514\u2500\u2500 logging.conf           # optional\n</code></pre> <p>Note: Paths are case-sensitive on Linux/macOS; keep names exactly as shown. Key Change: Configuration is now in human-readable YAML format at the project root, loaded via <code>config_loader.py</code>.</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#requirements","title":"\ud83d\udce6 Requirements","text":"<ul> <li>Python: 3.8+</li> <li>Python packages: <code>pandas</code>, <code>openpyxl</code>, <code>textfsm</code>, <code>paramiko</code>, <code>netmiko</code></li> <li>(Windows only, optional) <code>pywin32</code> for Windows Credential Manager integration</li> </ul> <p>Install in one go:</p> <pre><code>pip install pandas openpyxl textfsm paramiko netmiko pywin32\n</code></pre>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#tested-devices","title":"Tested Devices","text":"<p>This tool has been tested and verified on the following Cisco IOS and IOS-XE platforms:</p> <ul> <li>Catalyst 9200 Series</li> <li>Catalyst 3650 Series</li> <li>Catalyst 3650C</li> <li>Catalyst 3650CG</li> <li>Catalyst 3650CX</li> <li>Catalyst 2960X Series</li> <li>Catalyst 2960 Series</li> </ul> <p>Note: The tool should work with any Cisco IOS/IOS-XE device that supports CDP and the required show commands. The devices listed above have been explicitly tested and validated.</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#required-support-files","title":"Required Support Files","text":"<ul> <li>TextFSM templates:</li> <li><code>ProgramFiles/textfsm/cisco_ios_show_cdp_neighbors_detail.textfsm</code></li> <li><code>ProgramFiles/textfsm/cisco_ios_show_version.textfsm</code></li> <li>Excel template:</li> <li><code>ProgramFiles/config_files/1 - CDP Network Audit _ Template.xlsx</code></li> </ul> <p>The script validates presence of these files at startup and exits if any are missing.</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#configuration-options","title":"\u2699\ufe0f Configuration Options","text":"<p>The tool uses a comprehensive YAML-based configuration system with two configuration methods:</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#method-1-configyaml-primary-yaml-configuration","title":"Method 1: config.yaml (Primary) \u2014 YAML Configuration","text":"<p>All configurable settings are centralized in a YAML configuration file located at the project root.</p> <p>The <code>config.yaml</code> file provides a human-readable, version-control-friendly format for all settings. The configuration is loaded via <code>ProgramFiles/config_files/config_loader.py</code> which provides a <code>Config</code> class with property accessors for type-safe configuration access.</p> <p>Key settings include:</p> <p>Network Connection Settings (YAML): <pre><code>network:\n  jump_host: \"192.0.2.10\"  # Default jump/bastion server\n  device_type: \"cisco_ios\"    # Netmiko device type\n  ssh_port: 22                # SSH port for connections\n</code></pre></p> <p>Performance Settings (YAML): <pre><code>performance:\n  default_limit: 10            # Max concurrent worker threads\n  default_timeout: 10          # SSH/auth/read timeouts (seconds)\n  max_retry_attempts: 3        # Connection retries per device\n  dns_max_workers: 32          # Max DNS resolution threads\n  dns_min_workers: 4           # Min DNS resolution threads\n</code></pre></p> <p>Credential Settings (YAML): <pre><code>credentials:\n  cred_target: \"MyApp/ADM\"     # Primary credential target in Windows Credential Manager\n  alt_creds: \"MyApp/Answer\"    # Fallback credential target\n  cdp_fallback_username: \"answer\"  # Fallback username (fully customizable!)\n</code></pre></p> <p>Why YAML Configuration?</p> <ul> <li>Human-Readable: Easy to read and edit without Python knowledge</li> <li>Version Control Friendly: Plain text format works seamlessly with Git</li> <li>Hierarchical Structure: Natural grouping of related settings</li> <li>Comment Support: Inline documentation stays with configuration</li> <li>Type Safety: Config loader validates types and provides sensible defaults</li> <li>No Code Execution: Unlike Python config files, YAML is data-only (safer)</li> </ul> <p>File Paths (YAML): <pre><code>paths:\n  cdp_template: \"ProgramFiles/textfsm/cisco_ios_show_cdp_neighbors_detail.textfsm\"\n  ver_template: \"ProgramFiles/textfsm/cisco_ios_show_version.textfsm\"\n  excel_template: \"ProgramFiles/config_files/1 - CDP Network Audit _ Template.xlsx\"\n  logging_config: \"ProgramFiles/Config_Files/logging.conf\"\n</code></pre></p> <p>Excel Report Settings (YAML): <pre><code>excel:\n  sheet_audit: \"Audit\"\n  sheet_dns: \"DNS Resolved\"\n  sheet_auth_errors: \"Authentication Errors\"\n  sheet_conn_errors: \"Connection Errors\"\n  cell_site_name: \"B4\"\n  cell_date: \"B5\"\n  # ... and many more Excel customization options\n</code></pre></p> <p>Note: The config.yaml file contains comprehensive settings covering network, credentials, paths, Excel formatting, DNS, logging, and more. See the file directly for complete details and usage examples.</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#method-2-environment-variables-override","title":"Method 2: Environment Variables (Override)","text":"<p>Environment variables can override specific config.yaml settings at runtime:</p> Variable Description config.yaml Default <code>CDP_LIMIT</code> Max concurrent worker threads 10 <code>CDP_TIMEOUT</code> SSH/auth/read timeouts (seconds) 10 <code>CDP_JUMP_SERVER</code> Jump host (IP/hostname). Empty = direct \"\" <code>CDP_PRIMARY_CRED_TARGET</code> CredMan target for primary creds MyApp/ADM <code>CDP_FALLBACK_CRED_TARGET</code> CredMan target for fallback creds MyApp/Answer <code>CDP_FALLBACK_USERNAME</code> Fallback username answer <code>LOGGING_CONFIG</code> Path to INI logging config ProgramFiles/Config_Files/logging.conf <p>Example (Windows PowerShell):</p> <pre><code>$env:CDP_LIMIT = \"20\"\n$env:CDP_TIMEOUT = \"15\"\n$env:CDP_JUMP_SERVER = \"bastion.corp.local\"\n$env:CDP_PRIMARY_CRED_TARGET = \"MyApp/ADM\"\n$env:CDP_FALLBACK_CRED_TARGET = \"MyApp/LocalAdmin\"\n$env:CDP_FALLBACK_USERNAME = \"localadmin\"\n$env:LOGGING_CONFIG = \"ProgramFiles/Config_Files/logging.conf\"\n</code></pre> <p>When to Use Environment Variables: - Temporary overrides for testing - Different settings per environment (dev/staging/prod) - CI/CD pipelines with dynamic configuration - Running multiple instances with different settings</p> <p>Best Practice: Use config.yaml for persistent organizational defaults, and environment variables for runtime-specific overrides.</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#technical-architecture","title":"\ud83c\udfd7\ufe0f Technical Architecture","text":"<p>The tool operates as a modular Python application with four primary components:</p> Component Responsibility Why It Matters CredentialManager Secure credential collection and OS integration Passwords stay out of code and config files NetworkDiscoverer Multi-threaded topology crawling via CDP Discovers 50+ devices in seconds, not minutes ExcelReporter Professional, templated report generation Maintains business branding and formatting Logging &amp; Validation Pre-flight checks and operational visibility Catches problems early; provides audit trail","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#credentials-model","title":"\ud83d\udd10 Credentials Model","text":"<p>This tool supports a primary credential and a fully customizable fallback credential:</p> <ul> <li>Primary credentials (used for the jump and the device): read from Windows Credential Manager if present (default target <code>MyApp/ADM</code>), else prompted. You can optionally save what you type back to Credential Manager.</li> <li>Fallback credentials (device hop only, jump still uses primary): username is fully customizable via config.yaml (default: <code>answer</code>). Password is read from Credential Manager (default target <code>MyApp/Answer</code>) or prompted; you may choose to save it.</li> </ul> <p>Note: On non-Windows platforms, prompts are used (no Credential Manager).</p> <p>Customization: Change the fallback username in <code>config.yaml</code> by setting <code>cdp_fallback_username</code> under the <code>credentials</code> section to match your environment (e.g., <code>localadmin</code>, <code>backup</code>, <code>netops</code>, <code>svc_network</code>).</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#why-credential-management-matters","title":"Why Credential Management Matters","text":"<p>The Problem: Network automation requires credentials. Storing them in plaintext files or hardcoding them in scripts is a security nightmare. Even prompting users every time is error-prone and doesn't scale to 10+ discovery jobs daily.</p> <p>The Solution: Leverage native OS credential stores. Windows has Credential Manager, macOS has Keychain, Linux has pass. These are designed for exactly this use case and integrate with enterprise SSO/password managers.</p> <p>User Experience: When you run CDP Network Audit for the first time, the script checks Windows Credential Manager for stored credentials. If none are found, it prompts you to enter your username and password. Once you provide them, the script saves them to Windows Credential Manager and uses them for the discovery process. On subsequent runs, the script retrieves the stored credentials automatically without prompting you again.</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#credentialmanager__init__","title":"<code>CredentialManager.__init__()</code>","text":"<pre><code>def __init__(self):\n    # Load YAML config via config_loader module\n    from ProgramFiles.config_files.config_loader import Config\n    config = Config()\n\n    # Read from environment variables (override) or config.yaml (default)\n    self.primary_target = os.getenv(\"CDP_PRIMARY_CRED_TARGET\", config.CRED_TARGET)\n    self.fallback_target = os.getenv(\"CDP_FALLBACK_CRED_TARGET\", config.ALT_CREDS)\n    self.fallback_username = os.getenv(\"CDP_FALLBACK_USERNAME\", config.CDP_FALLBACK_USERNAME)\n</code></pre> <p>Line-by-Line: - Import the Config class from <code>config_loader.py</code> which parses <code>config.yaml</code> - Instantiate Config to load YAML settings with validation and type safety - Environment variables override YAML config if set (for runtime flexibility) - Three configurable values: primary target, fallback target, and fallback username - The config loader validates YAML syntax and provides defaults for missing values</p> <p>Why This Matters: - config.yaml: Human-readable, persistent, version-controlled settings that match your organization's standards - Environment variables: Runtime overrides for different environments (dev/prod) or testing - Config loader: Provides type-safe property accessors and validation - Fallback username: No longer hardcoded\u2014customize in config.yaml to match your local accounts (e.g., <code>localadmin</code>, <code>netops</code>, <code>backup</code>) - Separation of concerns: Configuration data (YAML) is separate from configuration logic (Python class) - Credentials themselves are still stored securely in Credential Manager (Windows) or prompted on other platforms</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#_read_win_credtarget_name-str","title":"<code>_read_win_cred(target_name: str)</code>","text":"<p>Reads encrypted credentials from Windows Credential Manager. Returns <code>(username, password)</code> tuple or <code>(None, None)</code> if not found.</p> <p>Key Points: - Only imports <code>win32cred</code> if available (Windows only) - Handles both bytes and string returns for compatibility - Decodes password from UTF-16LE (Windows internal format) - Gracefully fails and returns None instead of crashing</p> <p>Why This Approach: - No plaintext storage: Credentials are encrypted by Windows - Cross-platform: Non-Windows systems skip this and use prompts - Version-agnostic: Works with multiple pywin32 versions</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#_write_win_credtarget-str-username-str-password-str-bool","title":"<code>_write_win_cred(target: str, username: str, password: str) -&gt; bool</code>","text":"<p>Writes credentials to Windows Credential Manager for future reuse. Users can optionally save credentials after first prompt.</p> <p>Key Points: - Password is encoded to UTF-16LE before storage (Windows requirement) - <code>CRED_PERSIST_LOCAL_MACHINE</code> means credentials persist across sessions - Failures are logged at DEBUG level (not alarming) - Returns <code>True</code> on success, <code>False</code> on failure</p> <p>Why This Matters: - Users can avoid re-prompting on subsequent runs - Credentials are encrypted and protected by Windows - Optional save means users control persistence</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#get_secret_with_fallback-tuplestr-str","title":"<code>get_secret_with_fallback(...) -&gt; Tuple[str, str]</code>","text":"<p>The credential retrieval orchestrator with multi-step fallback:</p> <ol> <li>Try Credential Manager first (if Windows)</li> <li>Fall back to interactive prompt</li> <li>Optionally save to Credential Manager</li> </ol> <p>Two-Credential Model: - Primary: Your main automation account (flexible username, likely AD-backed) - Fallback: A secondary user on each device (username customisable in <code>config.py</code>, typically a local account)</p> <p>Why This Design: - Zero installation friction - first run prompts, subsequent runs use saved credentials - Two credentials maximise success: primary fails \u2192 retry with fallback - Jump host always uses primary (tighter control) - Device can fall back to secondary user (local account) - Fully customisable to match your organisation's account naming standards</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#jump-server-behaviour","title":"\ud83c\udf10 Jump Server Behaviour","text":"<ul> <li>Set <code>jump_host</code> in the <code>network</code> section of <code>config.yaml</code> to specify a default jump host.</li> <li>Alternatively, use the <code>CDP_JUMP_SERVER</code> environment variable to override at runtime.</li> <li>If empty, you will be prompted during runtime; leaving it blank uses direct device connections.</li> <li>The jump is created with Paramiko and a <code>direct-tcpip</code> channel; Netmiko is then bound to that channel (no local listener required).</li> </ul> <p>Note: Host key policy defaults to a warning (accepts unknown keys but logs a warning). For production environments, prefer strict host key checking via <code>known_hosts</code> management.</p> <p>Tip: Configure your jump server in <code>config.yaml</code> (<code>jump_host: \"192.0.2.10\"</code>) for permanent use, or leave it empty to be prompted each time for flexibility.</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#quick-start-using-the-launcher-recommended","title":"\ud83d\ude80 Quick Start: Using the Launcher (Recommended)","text":"<p>The repository now includes a professional Windows batch launcher (<code>run.bat</code>) that provides the easiest way to run the tool with default settings.</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#why-use-the-launcher","title":"Why Use the Launcher?","text":"<ul> <li>Zero configuration required - Just double-click or run from command line</li> <li>Automatic validation - Checks for Python environment and required files before execution</li> <li>Helpful diagnostics - Clear error messages if something is missing</li> <li>Professional interface - Clean output with status indicators and progress messages</li> <li>Safe execution - Validates environment before running the script</li> </ul>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#using-runbat","title":"Using run.bat","text":"<p>Option 1: Double-click</p> <p>Simply double-click <code>run.bat</code> in Windows Explorer to launch the tool with default behavior.</p> <p>Option 2: Command Line (Default Behavior)</p> <pre><code>run.bat\n</code></pre> <p>This runs the CDP Network Audit with all default settings from <code>config.yaml</code>.</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#what-the-launcher-does","title":"What the Launcher Does","text":"<ol> <li>Validates the environment:</li> <li>Checks that the <code>portable_env</code> virtual environment exists</li> <li>Verifies Python executable is present</li> <li>Confirms <code>main.py</code> exists</li> <li>Validates required TextFSM templates are present</li> <li> <p>Validates Excel template exists</p> </li> <li> <p>Provides clear feedback:</p> </li> <li>Shows [OK] for successful checks</li> <li>Shows [WARNING] for missing optional files</li> <li>Shows [ERROR] for critical missing components</li> <li> <p>Displays helpful troubleshooting tips on failure</p> </li> <li> <p>Runs the tool:</p> </li> <li>Activates the virtual environment</li> <li>Executes the main script</li> <li>Captures and displays the exit code</li> <li>Provides common troubleshooting tips if errors occur</li> </ol>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#example-output","title":"Example Output","text":"<pre><code>================================================================================\n                    CDP NETWORK AUDIT TOOL\n================================================================================\n\nStarting validation checks...\n\n[OK] Python Environment: Found at portable_env\\Scripts\\python.exe\n[OK] Required support files found\n[OK] All validation checks passed\n\n================================================================================\n\nRunning CDP Network Audit...\n\n================================================================================\n\n[Script output appears here]\n\n================================================================================\n\n[SUCCESS] Script completed successfully\n\n================================================================================\n</code></pre>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#advanced-command-line-with-arguments","title":"\ud83d\ude80 Advanced: Command Line with Arguments","text":"<p>For advanced users who need to customize behavior beyond the defaults, you can still run the tool directly with Python and command-line arguments.</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#when-to-use-command-line-arguments","title":"When to Use Command Line Arguments","text":"<p>Use <code>python main.py</code> with arguments when you need to:</p> <ul> <li>Override default settings from <code>config.yaml</code></li> <li>Run with different parameters for testing</li> <li>Integrate with automation scripts</li> <li>Pass runtime-specific configuration</li> </ul>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#method-1-using-the-launcher-with-arguments","title":"Method 1: Using the Launcher with Arguments","text":"<p>You can pass arguments to <code>run.bat</code> and they will be forwarded to the Python script:</p> <pre><code>run.bat --timeout 20 --workers 15\n</code></pre>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#method-2-direct-python-execution","title":"Method 2: Direct Python Execution","text":"","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#how-to-run-interactive-flow","title":"\ud83d\ude80 How to Run (Interactive Flow)","text":"<ol> <li>Ensure templates and Excel file exist under <code>ProgramFiles/...</code> (see above).</li> <li>(Optional) Customize <code>config.yaml</code> with your organization's defaults.</li> <li>(Optional) Set environment variables as needed for runtime overrides.</li> <li>Run:</li> </ol> <pre><code>python -m main\n# or: python main.py\n</code></pre> <ol> <li>Follow prompts:</li> <li>Site name (used in the output filename)</li> <li>Seed devices (comma-separated IPv4 / resolvable hostnames)</li> <li>Primary credentials (reads from CredMan if present; else prompts; optional save)</li> <li>Fallback password (username from <code>config.yaml</code>; reads from CredMan if present; else prompts; optional save)</li> <li>Jump server (from <code>config.yaml</code>, env var, or prompt; blank = direct)</li> </ol> <p>The tool validates/normalises seeds to IP addresses, de-duplicates them, then starts the threaded discovery.</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#what-gets-collected","title":"\ud83e\uddea What Gets Collected","text":"<p>For each visited device the tool attempts to collect:</p> <ul> <li><code>show version</code> (hostname, serials, uptime) \u2014 for local context.</li> <li><code>show cdp neighbors detail</code> \u2014 parsed into structured rows.</li> <li>DNS resolution for all discovered hostnames (best-effort), in parallel.</li> </ul>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#discovery-heuristics","title":"Discovery Heuristics","text":"<ul> <li>Only Switch-capable CDP entries (and not hosts) with a management IP are queued as crawl candidates.</li> <li>Deduplication is performed by hostname and IP to reduce churn.</li> <li>Each target is retried up to 3 times for transient connectivity issues.</li> </ul>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#prompt_for_inputs","title":"<code>prompt_for_inputs()</code>","text":"<p>Orchestrates all interactive input collection in one flow:</p> <ol> <li>Site name - Used in Excel filename (max 50 chars)</li> <li>Seed devices - Comma-separated IPs or hostnames</li> <li>Primary credentials - Main automation account</li> <li>Fallback credentials - Fallback device account (username from <code>config.py</code>, default: <code>answer</code>)</li> </ol>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#networkdiscoverer-the-threaded-discovery-engine","title":"\ud83d\udd0c NetworkDiscoverer: The Threaded Discovery Engine","text":"","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#why-parallel-discovery-is-essential","title":"Why Parallel Discovery is Essential","text":"<p>The Problem: Discovering 50+ switches serially takes 10+ minutes. Each SSH connection is a round-trip: connect, execute, disconnect.</p> <p>The Solution: Thread pool with 10 concurrent workers = 5x faster. 10 simultaneous connections instead of waiting for each one.</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#thread-safe-data-accumulators","title":"Thread-Safe Data Accumulators","text":"<pre><code># What we track (all thread-safe)\nself.cdp_neighbor_details = []  # Parsed CDP entries\nself.hostnames = set()           # Discovered hostnames for DNS\nself.visited = set()             # IPs we've already audited\nself.authentication_errors = set() # Auth failures\nself.connection_errors = {}      # {IP: error_message}\nself.dns_ip = {}                 # {hostname: resolved_ip}\n\n# Protection mechanisms\nself.visited_lock = threading.Lock()  # Protects queue management\nself.data_lock = threading.Lock()     # Protects result accumulators\n</code></pre> <p>Why Two Locks? - If we used one lock for everything, threads would block each other constantly - Granular locks allow more independent work - <code>visited_lock</code> for quick \"is this already being processed?\" checks - <code>data_lock</code> for appending results</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#parse_outputs_and_enqueue_neighbors","title":"<code>parse_outputs_and_enqueue_neighbors(...)</code>","text":"<p>This is the intelligence of the discovery engine. It decides which devices to audit next.</p> <p>Three-Step Process:</p> <p>Step 1: Parse Device Context - Extract hostname, serial, uptime from <code>show version</code> - Fall back to IP if parsing fails</p> <p>Step 2: Parse CDP Neighbors - Extract each neighbor's details (ports, capabilities, management IP) - Store in thread-safe list</p> <p>Step 3: Apply Queueing Heuristic</p> <p>Only enqueue if ALL three conditions are true:</p> <pre><code>if \"Switch\" in caps and \"Host\" not in caps and mgmt_ip:\n</code></pre> <p>Why \"Switch\" in caps? - CDP capability strings like \"Switch Router\" identify infrastructure - We only want to audit infrastructure nodes, not endpoints</p> <p>Why \"Host\" not in caps? - IP phones, printers, cameras also show up in CDP - Their capability includes \"Host\" but we can't/shouldn't manage them</p> <p>Why mgmt_ip? - If a device doesn't advertise a management IP, we have no way to SSH to it - Queueing it would just cause failures</p> <p>Example: <pre><code>Router (Switch, Router) + 192.0.2.5  \u2192 Queue it\nIP Phone (Host) + 192.0.2.50         \u2192 Skip (endpoint)\nAccess Point (Host) + no Mgmt IP     \u2192 Skip (non-addressable)\n</code></pre></p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#_paramiko_jump_client-paramikosshclient","title":"<code>_paramiko_jump_client(...) -&gt; paramiko.SSHClient</code>","text":"<p>Creates a secure SSH connection to a jump/bastion host.</p> <p>Key Design Choices: - <code>WarningPolicy()</code> - Log warnings for unknown hosts (safer than AutoAddPolicy) - Explicit password auth only - No SSH keys or agent (easier to audit) - Consistent timeouts - All operations respect <code>CDP_TIMEOUT</code> setting - Re-raise auth failures - Let caller handle credential issues</p> <p>Why WarningPolicy? - Accepts unknown hosts but logs warnings - Catches potential man-in-the-middle attacks without crashing - Production-ready security posture</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#_netmiko_via_jump-connecthandler","title":"<code>_netmiko_via_jump(...)  -&gt; ConnectHandler</code>","text":"<p>The core connection function. Handles both direct and jump-host connections.</p> <p>Credential Logic: <pre><code>if primary:\n    jump_user, jump_pass = primary_user, primary_pass\n    device_user, device_pass = primary_user, primary_pass\nelse:\n    jump_user, jump_pass = primary_user, primary_pass  # Jump always uses primary\n    device_user, device_pass = fallback_user, fallback_pass  # Device uses fallback\n</code></pre></p> <p>Why This Two-Credential Model: - Jump host always uses primary (tightest control) - Device can use fallback if primary fails (username customisable in <code>config.py</code>) - Resilience: if your primary account is locked, fallback account can still work - Flexibility: adapt to your organisation's local account naming conventions</p> <p>Direct Connection: Simply pass device IP to Netmiko.</p> <p>Jump-Mediated Connection: 1. Open Paramiko SSH to jump host 2. Create <code>direct-tcpip</code> channel (SSH tunnel) through jump to target 3. Wrap channel as socket 4. Pass socket to Netmiko for SSH auth</p> <p>Why direct-tcpip? - No need to open a listener on the jump host - No port forwarding configuration required - All traffic is inside the already-authenticated SSH session - Secure and clean</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#run_device_commands-tuplestr-str","title":"<code>run_device_commands(...) -&gt; Tuple[str, str]</code>","text":"<p>Executes CDP and version commands on target device with fallback credentials.</p> <p>Strategy: 1. Try with primary credentials 2. On auth failure, catch and retry with fallback (customisable fallback user on device) 3. Don't retry auth failures (credentials won't change between attempts) 4. Do retry transient errors (timeouts, SSH glitches) up to 3 times 5. Always disconnect in finally block (prevent socket leaks)</p> <p>Why This Approach: - Maximizes success rate with two-credential strategy - Transient timeouts are retried (network glitches happen) - Auth failures fail-fast (no point retrying) - Finally block ensures resource cleanup</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#discover_worker-none","title":"<code>discover_worker(...) -&gt; None</code>","text":"<p>The worker thread function. Multiple instances run concurrently.</p> <p>Loop: 1. Get next host from queue (timeout=1.0 prevents hangs) 2. Recognize sentinel (None = shutdown signal) 3. Check if already visited (prevent duplicate work) 4. Execute discovery with up to 3 retries 5. Parse outputs and enqueue new neighbors 6. Always call <code>task_done()</code> or queue.join() will hang</p> <p>Why Sentinel Pattern? - None signals worker to exit gracefully - Main thread sends one sentinel per worker - Coordinated shutdown without races</p> <p>Why Check If Already Visited? - Concurrent workers might both process same IP - Prevent duplicate discovery work - Track with hostname and IP</p> <p>Why task_done() Is Critical: Without <code>task_done()</code>, <code>queue.join()</code> waits forever on main thread. This is a common source of hangs in multi-threaded code!</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#resolve_dns_parallel-none","title":"<code>resolve_dns_parallel() -&gt; None</code>","text":"<p>After discovery, resolve all discovered hostnames to IPs in parallel.</p> <p>Design: - ThreadPoolExecutor with 4-32 workers (based on CDP_LIMIT) - Submit all resolutions concurrently - Collect results as they complete (don't wait for slowest) - Best-effort - failures are logged but don't block</p> <p>Why Separate from Discovery? - DNS lookups are independent - Can run in smaller thread pool (4-32 vs. 10) - Doesn't block discovery if DNS is slow</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#excelreporter-professional-reporting","title":"\ud83d\udcca ExcelReporter: Professional Reporting","text":"","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#why-professional-reporting-matters","title":"Why Professional Reporting Matters","text":"<p>The Problem: Raw CSV or unformatted Excel is not useful for business. Reports need context, formatting, branding.</p> <p>The Solution: Use a pre-formatted Excel template. Write data into it while preserving all formatting, charts, filters, and branding.</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#template-driven-approach","title":"Template-Driven Approach","text":"<p>Step 1: Copy Template <pre><code>shutil.copy2(template, output_filename)\n</code></pre></p> <p>Preserve metadata (timestamps, permissions).</p> <p>Step 2: Stamp Metadata <pre><code>ws[\"B4\"] = site_name\nws[\"B5\"] = date\nws[\"B6\"] = time\nws[\"B7\"] = seed1\nws[\"B8\"] = seed2\n</code></pre></p> <p>Fill cells B4-B8 with audit metadata.</p> <p>Step 3: Append Data <pre><code>df.to_excel(writer, sheet_name=\"Audit\", startrow=11, header=False)\n</code></pre></p> <p>Use <code>if_sheet_exists=\"overlay\"</code> mode to append without destroying template.</p> <p>Data starts at row 12 (after headers and metadata).</p> <p>Why This Approach: - Template-driven: Business controls formatting without touching code - Non-destructive: Data is appended, template is preserved - Professional: Charts, filters, styling all maintained - Automated: No manual Excel editing required</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#output-file-details","title":"Output File Details","text":"<p>An output file named <code>&lt;site_name&gt;_CDP_Network_Audit.xlsx</code> is created by copying the template.</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#sheets","title":"Sheets","text":"<ul> <li>Audit \u2014 Main CDP dataset. Also stamped with metadata:</li> <li><code>B4</code>: Site name</li> <li><code>B5</code>: Date</li> <li><code>B6</code>: Time</li> <li><code>B7</code>: Primary seed</li> <li><code>B8</code>: Secondary seed (or \"Secondary Seed device not given\")</li> <li>DNS Resolved \u2014 Two columns: <code>Hostname</code>, <code>IP Address</code></li> <li>Authentication Errors \u2014 One column: <code>Authentication Errors</code> (IP list)</li> <li>Connection Errors \u2014 Two columns: <code>IP Address</code>, <code>Error</code></li> </ul>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#columns-in-audit-data-rows","title":"Columns in Audit (Data Rows)","text":"<p><code>LOCAL_HOST</code>, <code>LOCAL_IP</code>, <code>LOCAL_PORT</code>, <code>LOCAL_SERIAL</code>, <code>LOCAL_UPTIME</code>, <code>DESTINATION_HOST</code>, <code>REMOTE_PORT</code>, <code>MANAGEMENT_IP</code>, <code>PLATFORM</code>.</p> <p>Note: The template governs formatting/filters/charts (if any). The writer appends data starting at the appropriate row offsets to preserve the layout.</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#key-design-patterns","title":"\ud83d\udd11 Key Design Patterns","text":"","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#pattern-1-thread-safe-data-accumulation","title":"Pattern 1: Thread-Safe Data Accumulation","text":"<p><pre><code>with self.data_lock:\n    self.results.append(new_data)\n</code></pre> Only one thread updates shared data at a time.</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#pattern-2-graceful-worker-shutdown","title":"Pattern 2: Graceful Worker Shutdown","text":"<pre><code>for _ in range(num_workers):\n    queue.put(None)  # Sentinel\n\n# In worker\nif item is None:\n    return  # Exit gracefully\n</code></pre>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#pattern-3-retry-with-fallback-credentials","title":"Pattern 3: Retry with Fallback Credentials","text":"<pre><code>try:\n    conn = connect(primary_user, primary_pass)\nexcept AuthenticationException:\n    conn = connect(answer_user, answer_pass)  # Fallback\n</code></pre>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#pattern-4-resource-cleanup-in-finally","title":"Pattern 4: Resource Cleanup in Finally","text":"<pre><code>try:\n    conn = connect()\nfinally:\n    if conn:\n        conn.disconnect()  # ALWAYS happens\n</code></pre>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#pattern-5-template-driven-reporting","title":"Pattern 5: Template-Driven Reporting","text":"<p>Copy \u2192 stamp metadata \u2192 append data using overlay mode.</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#logging","title":"\ud83e\uddf0 Logging","text":"<ul> <li>If a config file is present, logging is configured via <code>logging.config.fileConfig()</code>.</li> <li>Otherwise, a basic console logger is configured at INFO with timestamps.</li> <li>You can set <code>LOGGING_CONFIG</code> to point to an INI file anywhere; if not set, the tool looks for <code>ProgramFiles/Config_Files/logging.conf</code>.</li> </ul>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#errors-retry-behaviour","title":"\ud83e\uddef Errors &amp; Retry Behaviour","text":"<ul> <li>Authentication failures: the host is recorded under Authentication Errors.</li> <li>Connectivity/timeouts: the host is recorded under Connection Errors with the last error tag (e.g., <code>NetmikoTimeoutException</code>, <code>SSHException</code>, <code>socket.timeout</code>).</li> <li>Retries: up to 3 attempts for each device before recording a connection error.</li> <li>Graceful exit: workers always <code>task_done()</code> to avoid queue hangs.</li> </ul>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#performance","title":"\ud83d\udcc8 Performance","text":"<ul> <li>Worker threads = <code>CDP_LIMIT</code> (default 10).</li> <li>DNS resolution runs in a small parallel pool after discovery.</li> <li>Use a conservative limit on older/CPU-bound platforms; increase on fast links.</li> </ul>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#security-considerations","title":"\ud83d\udd12 Security Considerations","text":"<ul> <li>Prefer Credential Manager (Windows) or other secret stores instead of plaintext.</li> <li>Ensure jump host is hardened; consider strict host key verification.</li> <li>Output workbooks can contain sensitive topology data \u2014 share on a need-to-know basis.</li> </ul>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#exit-codes","title":"\u274c Exit Codes","text":"<ul> <li>0 \u2014 Success</li> <li>1 \u2014 Required TextFSM or Excel template missing / invalid</li> <li>130 \u2014 Interrupted by user (Ctrl+C)</li> </ul>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#example-session","title":"\u2705 Example Session","text":"<pre><code>=== CDP Network Audit ===\nEnter site name (used in Excel filename, max 50 chars): HQ-Campus\nEnter one or more seed device IPs or hostnames (comma-separated, max 500): 192.0.2.11, core-sw-1\n...\nPress Enter to accept, or type a different username: netadmin\nEnter switch/jump password (Primary): ********\nStore Primary creds in Credential Manager as 'MyApp/ADM'? [y/N]\nEnter 'answer' password (fallback user from config.yaml): ********\nStore 'answer' password in Credential Manager as 'MyApp/Answer'? [y/N]\n\nUse jump host '192.0.2.10'? [Y/n]\nPress Enter to accept the default shown.\n\nINFO Validated 2 seed device(s) for discovery\nINFO Using jump server: 192.0.2.10\n... (threaded discovery logs) ...\nDone!\n Discovered devices: 42\n CDP entries: 314\n Auth errors: 1\n Conn errors: 3\n</code></pre> <p>Note: The fallback username shown in the prompt reflects your <code>config.yaml</code> setting. Default is 'answer', but you can customise it to 'localadmin', 'backup', etc. by editing the <code>credentials</code> section of <code>config.yaml</code>.</p> <p>If you had customized your config.yaml:</p> <pre><code>credentials:\n  cdp_fallback_username: \"localadmin\"\n</code></pre> <p>The prompt would show:</p> <pre><code>Enter 'localadmin' password (fallback user from config.yaml): ********\n</code></pre>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#customisation-points","title":"\ud83d\udee0\ufe0f Customisation Points","text":"<ul> <li>User settings: Edit <code>config.yaml</code> to customise worker threads, timeouts, jump server, credential targets, and fallback username.</li> <li>Template paths: Adjust in <code>config.yaml</code> under the <code>paths</code> section.</li> <li>Queueing heuristics (which neighbors to crawl): Modify <code>parse_outputs_and_enqueue_neighbors()</code> in <code>main.py</code>.</li> <li>Retry counts / timeouts: Configure in <code>config.yaml</code> under <code>performance</code> or override via environment variables.</li> <li>Logging: Provide a <code>logging.conf</code> that matches your standards (path configurable in <code>config.yaml</code>).</li> <li>Fallback account: Set <code>cdp_fallback_username</code> in <code>config.yaml</code> (under <code>credentials</code>) to match your local admin account naming.</li> <li>Excel formatting: Customize cell locations and sheet names in <code>config.yaml</code> under <code>excel</code>.</li> </ul> <p>Example config.yaml Customization:</p> <pre><code>credentials:\n  cdp_fallback_username: \"localadmin\"  # Change from default 'answer'\n\nnetwork:\n  jump_host: \"bastion.corp.local\"  # Set your default jump host\n\nperformance:\n  default_limit: 15  # Increase concurrent workers for faster discovery\n  default_timeout: 15  # Increase timeout for slower networks\n</code></pre>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#learning-outcomes","title":"\ud83c\udf93 Learning Outcomes","text":"<p>After studying this code, you should understand:</p> <p>\u2705 Concurrent programming \u2014 How thread pools and locks prevent race conditions \u2705 SSH tunnelling \u2014 How direct-tcpip channels work and why they're safer \u2705 Credential management \u2014 OS-level credential stores vs. plaintext files \u2705 TextFSM parsing \u2014 How to extract structured data from CLI output \u2705 Error handling \u2014 Retry strategies and graceful degradation \u2705 Excel automation \u2014 Template-driven reporting with data overlay \u2705 Network discovery \u2014 CDP heuristics and neighbor crawling logic  </p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#distribution-execution","title":"\ud83d\ude80 Distribution &amp; Execution","text":"<p>Consistent with the Nautomation Prime delivery model, this tool is available in multiple formats:</p> <ul> <li> <p>Zero-Install Portable Bundle: A self-contained package including the Python interpreter and all libraries (Netmiko, Pandas, TextFSM) for use on restricted Windows jump boxes.</p> </li> <li> <p>Scheduled Docker Appliance: A pre-built container designed for autonomous execution and periodic auditing.</p> </li> </ul>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#repository-downloads","title":"\ud83d\udcc1 Repository &amp; Downloads","text":"<p>Ready to audit your own network? Access the hardened source code and pre-configured templates below.</p> <ul> <li> View Full Repository: Access the code, TextFSM templates, and Excel master.</li> <li> Download Latest Release: Get a clean ZIP of the production-ready files.</li> </ul>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#performance-tuning","title":"\ud83d\udcc8 Performance Tuning","text":"Scenario Configuration Rationale Fast LAN, many devices <code>CDP_LIMIT=20</code>, <code>CDP_TIMEOUT=5</code> High concurrency, short timeouts work Slow WAN link <code>CDP_LIMIT=5</code>, <code>CDP_TIMEOUT=30</code> Fewer threads prevent overwhelming network; higher timeout for round-trip delay Mixed (some LAN, some WAN) <code>CDP_LIMIT=10</code>, <code>CDP_TIMEOUT=10</code> Balanced defaults Device with high CPU <code>CDP_LIMIT=3-5</code> Fewer threads prevent overwhelming device","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#next-steps","title":"\ud83c\udfac Next Steps","text":"<ol> <li>Clone the repository: <code>git clone https://github.com/Nautomation-Prime/Cisco_CDP_Network_Audit</code></li> <li>Customise config.yaml to match your environment:</li> <li>Set <code>jump_host</code> under <code>network</code> section</li> <li>Customize <code>cdp_fallback_username</code> under <code>credentials</code> section</li> <li>Adjust <code>default_limit</code> and <code>default_timeout</code> under <code>performance</code> section</li> <li>Configure credential targets if different from defaults</li> <li>Read the README for installation and configuration details</li> <li>Set up credentials in Windows Credential Manager (or let the script prompt you on first run)</li> <li>Run your first discovery against a test device</li> <li>Review the Excel output to understand the report format</li> </ol> <p>Once comfortable, customise the discovery heuristics and template for your specific topology.</p> <p>Example config.yaml for Enterprise Use:</p> <pre><code>network:\n  jump_host: \"bastion.corp.example.com\"\n\ncredentials:\n  cdp_fallback_username: \"svc_network\"  # Enterprise service account\n  cred_target: \"NetworkAudit/Primary\"\n  alt_creds: \"NetworkAudit/Fallback\"\n\nperformance:\n  default_limit: 20  # Faster discovery for large environments\n  default_timeout: 15  # Accommodate slower WAN links\n</code></pre>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#licence","title":"\ud83d\udccb Licence","text":"<p>GNU General Public Licence v3.0</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"deep-dives/cdp-audit/#author","title":"\ud83d\udc64 Author","text":"<p>Christopher Davies</p> <p>Mission Statement: To empower engineers through Python-driven transparency and provide enterprises with hardened automation that eliminates error and accelerates growth.</p>","tags":["Deep Dive","CDP","Network Discovery","Threading","Jump Server","TextFSM","Excel"]},{"location":"legal/brand/","title":"Brand &amp; Logo Usage","text":"<p>Last updated: 30 January 2026</p> <p>All branding, logos, images, icons, and visual identifiers used on this website are the exclusive property of Nautomation Prime.</p> <p>They may not be:</p> <ul> <li>Copied  </li> <li>Modified  </li> <li>Reused  </li> <li>Embedded in derivative works  </li> <li>Included in other documentation  </li> </ul> <p>without prior written consent.</p> <p>Brand identity is not covered under any open\u2011source licence.</p>"},{"location":"legal/disclaimer/","title":"Disclaimer","text":"<p>Last updated: 30 January 2026</p>"},{"location":"legal/disclaimer/#1-no-affiliation-with-cisco","title":"1. No Affiliation With Cisco","text":"<p>This website and all related content are not affiliated, associated, endorsed, or sponsored by Cisco Systems, Inc.</p> <p>All Cisco\u2011related references are for documentation, education, and interoperability purposes only.</p>"},{"location":"legal/disclaimer/#2-educational-use-only","title":"2. Educational Use Only","text":"<p>All examples, guides, and documentation are provided for educational and informational purposes.</p> <p>They are not official vendor documentation and should not be treated as professional advice.</p>"},{"location":"legal/disclaimer/#3-no-guarantees-or-warranties","title":"3. No Guarantees or Warranties","text":"<p>All content, scripts, tools, and code examples are provided \"AS IS\" and \"AS AVAILABLE\" without any warranty of any kind, express or implied. This includes \u2014 but is not limited to \u2014 warranties of:</p> <ul> <li>Fitness for purpose  </li> <li>Accuracy or correctness  </li> <li>Suitability for production  </li> <li>Reliability or uptime  </li> <li>Merchantability or non-infringement  </li> </ul>"},{"location":"legal/disclaimer/#4-use-at-your-own-risk","title":"4. Use at Your Own Risk","text":"<p>Network automation can be inherently risky. Running scripts or commands may cause:</p> <ul> <li>Configuration loss  </li> <li>Service disruption  </li> <li>Security vulnerabilities  </li> <li>Device instability  </li> </ul> <p>Always test in a lab environment before applying anything to production.</p>"},{"location":"legal/disclaimer/#5-no-liability","title":"5. No Liability","text":"<p>Christopher Davies trading as Nautomation Prime assumes no liability whatsoever for any direct, indirect, incidental, consequential, or punitive damages, losses, outages, data loss, revenue loss, or any other side effects arising from:</p> <ul> <li>Use or misuse of information on this website  </li> <li>Deployment of scripts, tools, or code from repositories  </li> <li>Implementation of configuration examples or guides  </li> <li>Network downtime, device failures, or service disruption  </li> <li>Any reliance placed on the accuracy or completeness of materials provided  </li> </ul> <p>You acknowledge that network automation carries inherent risks and that you are solely responsible for testing, validating, and deploying any code or configuration in your environment.  </p>"},{"location":"legal/licensing/","title":"Licensing","text":"<p>Last updated: 30 January 2026</p> <p>This page explains how licensing works for code and content produced by Nautomation Prime.</p>"},{"location":"legal/licensing/#1-public-github-repositories","title":"1. Public GitHub Repositories","text":"<p>All public repositories published under the Nautomation Prime GitHub organisation are licenced under:</p>"},{"location":"legal/licensing/#gnu-general-public-licence-v30-gpl30","title":"GNU General Public Licence v3.0 (GPL\u20113.0)","text":"<p>This includes (but is not limited to):</p> <ul> <li>Network automation utilities  </li> <li>Python tools  </li> <li>Documentation examples tied to those repos  </li> </ul> <p>GPL\u20113.0 requires:</p> <ul> <li>Source code availability  </li> <li>Preservation of original licence terms  </li> <li>Copyleft distribution of derivative works  </li> </ul>"},{"location":"legal/licensing/#2-code-examples-on-this-website","title":"2. Code Examples on This Website","text":"<p>Unless otherwise stated, any code snippets or examples on this website are licenced under the same licence as the repository they relate to, typically GPL\u20113.0.</p> <p>If a snippet stands alone with no linked repository, GPL\u20113.0 applies by default.</p>"},{"location":"legal/licensing/#3-bespoke-client-code","title":"3. Bespoke Client Code","text":"<p>For paid or commissioned work, Nautomation Prime provides code under one of the following:</p> <ul> <li>MIT Licence (permissive)  </li> <li>Apache Licence 2.0 (permissive, includes patent protection)  </li> </ul> <p>The licence is chosen with the client during the project.</p>"},{"location":"legal/licensing/#4-brand-assets","title":"4. Brand Assets","text":"<p>All logos, branding, imagery, and visual design elements are:</p> <p>Copyright \u00a9 Nautomation Prime</p> <p>They are not licenced under GPL, MIT, or Apache licences and may not be reused without written permission.</p>"},{"location":"legal/privacy-policy/","title":"Privacy Policy","text":"<p>Last updated: 31 January 2026</p>"},{"location":"legal/privacy-policy/#operator-details","title":"Operator Details","text":"<p>This website is operated by: Christopher Davies trading as Nautomation Prime (\"we\", \"us\", \"our\")  </p> <p>Geographic Address: Christopher Davies T/A Nautomation Prime 9 The Sleeve Leek, ST138 HR Staffordshire England United Kingdom</p> <p>Email: nautomationprime.f3wfe@simplelogin.com</p> <p>This Privacy Policy explains what personal information is collected when you use this website and how it is handled.</p>"},{"location":"legal/privacy-policy/#1-data-collected","title":"1. Data Collected","text":"<p>This website itself does not:</p> <ul> <li>Collect personal data  </li> <li>Use cookies  </li> <li>Use analytics or tracking  </li> <li>Store logs for profiling or marketing purposes  </li> </ul> <p>When you contact us via email, we receive only the information you choose to include in your message.  </p>"},{"location":"legal/privacy-policy/#2-how-your-data-is-processed","title":"2. How Your Data Is Processed","text":"<p>Email communications are processed through our email provider SimpleLogin, which provides privacy-focused email forwarding.  </p> <p>SimpleLogin's privacy policy can be found here: https://simplelogin.io/privacy/</p>"},{"location":"legal/privacy-policy/#3-purpose-of-processing","title":"3. Purpose of Processing","text":"<p>We use the information you provide in email communications solely for:</p> <ul> <li>Responding to your enquiry  </li> <li>Discussing potential work or collaboration  </li> <li>Following up about questions you have raised  </li> </ul> <p>We do not use your data for marketing, sharing with third parties, or any unrelated purpose.</p>"},{"location":"legal/privacy-policy/#4-legal-basis","title":"4. Legal Basis","text":"<p>The legal bases for using your data are:</p> <ul> <li>Legitimate interest \u2014 to respond to your enquiry  </li> <li>Consent \u2014 which is provided when you contact us  </li> </ul>"},{"location":"legal/privacy-policy/#5-data-retention","title":"5. Data Retention","text":"<p>Email communications are kept only as long as necessary to handle your enquiry, unless ongoing collaboration or legal requirements necessitate longer retention. You may request deletion of your data at any time.</p>"},{"location":"legal/privacy-policy/#6-your-rights","title":"6. Your Rights","text":"<p>If you are in the UK or EU, you have the right to:</p> <ul> <li>Request access to your data  </li> <li>Request correction of inaccurate data  </li> <li>Request deletion of your data  </li> </ul> <p>To exercise these rights, please contact us via email at nautomationprime.f3wfe@simplelogin.com.</p>"},{"location":"legal/privacy-policy/#7-international-transfers","title":"7. International Transfers","text":"<p>SimpleLogin is a privacy-focused service that may process email data in regions outside the UK/EU under appropriate data protection safeguards.</p>"},{"location":"legal/privacy-policy/#8-childrens-privacy","title":"8. Children\u2019s Privacy","text":"<p>This website is not intended for individuals under 18. We do not knowingly collect information from minors.</p>"},{"location":"legal/privacy-policy/#9-contact","title":"9. Contact","text":"<p>For any privacy-related questions, please contact us at nautomationprime.f3wfe@simplelogin.com.</p>"},{"location":"legal/terms-of-use/","title":"Terms of Use","text":"<p>Last updated: 30 January 2026</p> <p>By using this website, you agree to the following Terms of Use.</p>"},{"location":"legal/terms-of-use/#1-ownership-of-website-content","title":"1. Ownership of Website Content","text":"<p>All content on this website \u2014 including text, diagrams, documentation, branding, and design \u2014 is the property of Nautomation Prime, unless otherwise stated.</p> <p>Website content may not be copied, republished, or redistributed without permission.</p>"},{"location":"legal/terms-of-use/#2-code-licensing","title":"2. Code Licensing","text":"<p>Code available in public repositories under the Nautomation Prime GitHub organisation is licenced under the GNU GPL\u20113.0 licence, unless stated otherwise.</p> <p>Bespoke code delivered to clients is licenced under either:</p> <ul> <li>MIT Licence, or  </li> <li>Apache Licence 2.0 </li> </ul> <p>as agreed upon during engagement.</p> <p>See the Licensing page for full details.</p>"},{"location":"legal/terms-of-use/#3-no-affiliation-with-third-parties-including-cisco","title":"3. No Affiliation With Third Parties (Including Cisco)","text":"<p>This website and its content are not affiliated, endorsed, associated, or sponsored by Cisco Systems, Inc. All references to Cisco devices, commands, and terminology exist solely for interoperability, documentation, and educational purposes.</p> <p>Cisco\u00ae, IOS\u00ae, IOS\u2011XE\u00ae, NX\u2011OS\u00ae, and other Cisco terms are trademarks of Cisco Systems, Inc.</p>"},{"location":"legal/terms-of-use/#4-no-warranty-of-any-kind","title":"4. No Warranty of Any Kind","text":"<p>All information, materials, scripts, tools, and code on this site are provided \"AS IS\" and \"AS AVAILABLE\", with no warranties or guarantees of any kind, express or implied, including (but not limited to):</p> <ul> <li>Fitness for a particular purpose  </li> <li>Safety for use in production environments  </li> <li>Accuracy, completeness, or reliability  </li> <li>Compatibility with any hardware, software, network platform, or vendor system  </li> <li>Merchantability or non-infringement  </li> </ul> <p>You acknowledge that you use all content entirely at your own risk and that network automation may cause configuration loss, service disruption, or device instability.</p>"},{"location":"legal/terms-of-use/#5-limitation-of-liability","title":"5. Limitation of Liability","text":"<p>To the maximum extent permitted by law, Christopher Davies trading as Nautomation Prime is not liable for any direct, indirect, incidental, consequential, or punitive damages, losses, outages, misconfigurations, data loss, revenue loss, business interruption, or any other harm resulting from:</p> <ul> <li>Use or misuse of code, scripts, or automation tools  </li> <li>Following guides, examples, or documentation  </li> <li>Implementing network\u2011related tasks or configurations  </li> <li>Relying on information, advice, or materials from this site  </li> <li>Network downtime, device failures, or security vulnerabilities  </li> </ul> <p>You acknowledge and agree that you are solely responsible for testing and validating any automation in your own lab environment before deploying to production.  </p>"},{"location":"legal/terms-of-use/#6-acceptable-use","title":"6. Acceptable Use","text":"<p>You agree not to:</p> <ul> <li>Attack, harm, or interfere with this website  </li> <li>Scrape or copy content without permission  </li> <li>Misrepresent yourself as affiliated with Nautomation Prime  </li> </ul>"},{"location":"legal/terms-of-use/#7-changes-to-terms","title":"7. Changes to Terms","text":"<p>These Terms may be updated at any time. Continued use of the site implies acceptance of any changes.</p>"},{"location":"scripts/","title":"Script Library","text":"","tags":["Scripts","Tools","Open Source","GitHub","Production Ready"]},{"location":"scripts/#production-ready-automation-for-cisco-infrastructure","title":"Production-Ready Automation for Cisco Infrastructure","text":"<p>Welcome to the Nautomation Prime Script Library. Here you'll find open-source, hardened Python automation tools designed for enterprise Cisco deployments.</p> <p>Important: All scripts on this site are written in Python. You should have prior Python knowledge (variables, functions, loops, exception handling). Our scripts are designed for clarity and include comments, but we don't teach Python basics. If you're new to Python, learn the fundamentals first, then return here.</p>","tags":["Scripts","Tools","Open Source","GitHub","Production Ready"]},{"location":"scripts/#available-scripts","title":"\ud83d\udcda Available Scripts","text":"","tags":["Scripts","Tools","Open Source","GitHub","Production Ready"]},{"location":"scripts/#cdp-network-audit-tool","title":"CDP Network Audit Tool","text":"<p>Status: \u2705 Available Description: A threaded discovery utility that starts from seed Cisco devices and crawls the network using Cisco Discovery Protocol (CDP), producing structured Excel reports with professional formatting.</p> <p>Features: - Parallel discovery with configurable worker pool (via config.py or environment variable overrides) - Centralised configuration with comprehensive config.py (200+ documented settings) - Two-tier authentication (primary user with customisable fallback username) - Jump server / bastion support (Paramiko channel + Netmiko sock) - DNS enrichment for discovered hostnames - Excel reporting from pre-formatted templates with multiple sheets - Hybrid logging with optional logging.conf - Up to 3 automatic retries for transient connectivity issues - Comprehensive error tracking (authentication failures, connection errors) - Extensive customisation options (credentials, paths, Excel formatting, DNS, logging, and more)</p> <p>\ud83d\udcd6 View Deep Dive Documentation |  GitHub Repository</p>","tags":["Scripts","Tools","Open Source","GitHub","Production Ready"]},{"location":"scripts/#access-switch-port-audit-tool","title":"Access Switch Port Audit Tool","text":"<p>Status: \u2705 Available Description: A production-hardened collector designed to map interface health and utilisation across your access layer.</p> <p>Features: - Parallel device SSH connections for high-speed audits - Conservative \"Stale Port\" detection logic using PoE, neighbours, and input timers - Multi-source port classification (Access vs. Trunk vs. Routed) - Professional Excel workbooks with automated conditional formatting - Full Jump-Host (Bastion) integration for restricted environments</p> <p>\ud83d\udcd6 View Deep Dive Documentation |  GitHub Repository</p>","tags":["Scripts","Tools","Open Source","GitHub","Production Ready"]},{"location":"scripts/#coming-soon","title":"\ud83d\udd04 Coming Soon","text":"","tags":["Scripts","Tools","Open Source","GitHub","Production Ready"]},{"location":"scripts/#zero-touch-provisioning-ztp-tool","title":"Zero Touch Provisioning (ZTP) Tool","text":"<p>Status: \ud83d\udea7 In Development Description: Automated deployment solution for Cisco devices that streamlines initial configuration and reduces deployment time from hours to minutes.</p> <p>Planned Features: - Automated device configuration from templates - DHCP option integration for network-based provisioning - Email notifications for deployment status and errors - HTTP server integration for configuration and log file management - Pre-flight validation and rollback capabilities - Multi-device orchestration with dependency management - Comprehensive logging with remote log collection</p> <p>Current Status: Core functionality tested and validated. Additional features (email notifications, HTTP log server integration) under active development.</p>","tags":["Scripts","Tools","Open Source","GitHub","Production Ready"]},{"location":"scripts/#ios-xe-software-upgrade-orchestrator","title":"IOS-XE Software Upgrade Orchestrator","text":"<p>Status: \ud83d\udea7 In Development Description: Automated, intelligent firmware management for Cisco IOS-XE switch stacks that eliminates manual upgrade errors and reduces downtime through comprehensive pre-flight validation.</p> <p>Planned Features: - Pre-flight validation (disk space, compatibility, current version checks) - Binary integrity verification (MD5/SHA checksums) - Automated file transfer to target devices (SCP/TFTP/HTTP) - Stack-aware upgrade orchestration with rolling restarts - Version compliance reporting across the estate - Rollback capability for failed upgrades - Parallel upgrade support for multiple stacks - Email notifications and comprehensive logging - Integration with maintenance windows and change control systems</p> <p>Current Status: Architecture and design phase. Feature set being finalized based on enterprise deployment requirements.</p>","tags":["Scripts","Tools","Open Source","GitHub","Production Ready"]},{"location":"scripts/#getting-started-with-scripts","title":"\ud83d\udee0\ufe0f Getting Started with Scripts","text":"","tags":["Scripts","Tools","Open Source","GitHub","Production Ready"]},{"location":"scripts/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.8+</li> <li>Netmiko or equivalent SSH library</li> <li>Network access to target devices</li> <li>Appropriate credentials/permissions</li> </ul>","tags":["Scripts","Tools","Open Source","GitHub","Production Ready"]},{"location":"scripts/#installation-setup","title":"Installation &amp; Setup","text":"<p>Each script repository includes detailed installation instructions in its README. Typical workflow:</p> <pre><code># Clone the repository\ngit clone https://github.com/Nautomation-Prime/&lt;script-name&gt;\ncd &lt;script-name&gt;\n\n# Install dependencies\npip install -r requirements.txt\n\n# Run with --help to see options\npython main.py --help\n</code></pre>","tags":["Scripts","Tools","Open Source","GitHub","Production Ready"]},{"location":"scripts/#credential-management","title":"Credential Management","text":"<p>Scripts use your operating system's native credential manager for secure authentication:</p> <ul> <li>Windows: CDP Network Audit prompts you to save credentials to Windows Credential Manager on first run. Enter your username and password when prompted, and the script will store them securely. Future runs use the stored credentials automatically.  </li> <li>macOS: Credentials are stored in Keychain - Upcoming  </li> <li>Linux: Credentials are stored in <code>pass</code> or similar managers - Upcoming  </li> </ul> <p>Credentials are never stored in plaintext files or hardcoded in scripts.</p> <p>See each repository's README for platform-specific instructions.</p>","tags":["Scripts","Tools","Open Source","GitHub","Production Ready"]},{"location":"scripts/#configuration","title":"Configuration","text":"<p>All scripts follow the Nautomation Prime philosophy of transparency and security: - Credentials are stored in OS credential managers (Windows Credential Manager, etc.) - Configuration files are well-documented with inline comments. - Pre-flight validation checks prevent unsafe deployments.  </p>","tags":["Scripts","Tools","Open Source","GitHub","Production Ready"]},{"location":"scripts/#support-questions","title":"Support &amp; Questions","text":"<p>For issues, feature requests, or questions about any script: - Check the Deep Dives documentation for detailed explanations. - Open an issue on the respective GitHub repository. - Contact us via email or LinkedIn for consulting services.  </p>","tags":["Scripts","Tools","Open Source","GitHub","Production Ready"]},{"location":"scripts/#the-prime-philosophy","title":"\ud83d\udcd6 The \"Prime\" Philosophy","text":"<p>All scripts in this library adhere to three core principles:</p> <ol> <li>Line-by-Line Transparency - Every function is documented, every decision explained  </li> <li>Hardened for Production - Robust error handling, security best practices, pre-flight checks  </li> <li>Vendor-Neutral - Built on industry-standard libraries like Netmiko, Nornir, and TextFSM  </li> </ol> <p>Mission: To empower engineers through Python-driven transparency and provide enterprises with hardened automation that eliminates error and accelerates growth.</p>","tags":["Scripts","Tools","Open Source","GitHub","Production Ready"]}]}